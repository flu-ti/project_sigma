{"version":3,"file":"js/home.js","mappings":"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","sources":["webpack://project_sigma/./node_modules/events/events.js","webpack://project_sigma/./node_modules/graphology-layout-forceatlas2/defaults.js","webpack://project_sigma/./node_modules/graphology-layout-forceatlas2/helpers.js","webpack://project_sigma/./node_modules/graphology-layout-forceatlas2/index.js","webpack://project_sigma/./node_modules/graphology-layout-forceatlas2/iterate.js","webpack://project_sigma/./node_modules/graphology-utils/getters.js","webpack://project_sigma/./node_modules/graphology-utils/is-graph.js","webpack://project_sigma/./node_modules/papaparse/papaparse.min.js","webpack://project_sigma/webpack/bootstrap","webpack://project_sigma/./node_modules/graphology/dist/graphology.mjs","webpack://project_sigma/./src/js/home.js"],"sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/**\n * Graphology ForceAtlas2 Layout Default Settings\n * ===============================================\n */\nmodule.exports = {\n  linLogMode: false,\n  outboundAttractionDistribution: false,\n  adjustSizes: false,\n  edgeWeightInfluence: 1,\n  scalingRatio: 1,\n  strongGravityMode: false,\n  gravity: 1,\n  slowDown: 1,\n  barnesHutOptimize: false,\n  barnesHutTheta: 0.5\n};\n","/**\n * Graphology ForceAtlas2 Helpers\n * ===============================\n *\n * Miscellaneous helper functions.\n */\n\n/**\n * Constants.\n */\nvar PPN = 10;\nvar PPE = 3;\n\n/**\n * Very simple Object.assign-like function.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nexports.assign = function (target) {\n  target = target || {};\n\n  var objects = Array.prototype.slice.call(arguments).slice(1),\n    i,\n    k,\n    l;\n\n  for (i = 0, l = objects.length; i < l; i++) {\n    if (!objects[i]) continue;\n\n    for (k in objects[i]) target[k] = objects[i][k];\n  }\n\n  return target;\n};\n\n/**\n * Function used to validate the given settings.\n *\n * @param  {object}      settings - Settings to validate.\n * @return {object|null}\n */\nexports.validateSettings = function (settings) {\n  if ('linLogMode' in settings && typeof settings.linLogMode !== 'boolean')\n    return {message: 'the `linLogMode` setting should be a boolean.'};\n\n  if (\n    'outboundAttractionDistribution' in settings &&\n    typeof settings.outboundAttractionDistribution !== 'boolean'\n  )\n    return {\n      message:\n        'the `outboundAttractionDistribution` setting should be a boolean.'\n    };\n\n  if ('adjustSizes' in settings && typeof settings.adjustSizes !== 'boolean')\n    return {message: 'the `adjustSizes` setting should be a boolean.'};\n\n  if (\n    'edgeWeightInfluence' in settings &&\n    typeof settings.edgeWeightInfluence !== 'number'\n  )\n    return {\n      message: 'the `edgeWeightInfluence` setting should be a number.'\n    };\n\n  if (\n    'scalingRatio' in settings &&\n    !(typeof settings.scalingRatio === 'number' && settings.scalingRatio >= 0)\n  )\n    return {message: 'the `scalingRatio` setting should be a number >= 0.'};\n\n  if (\n    'strongGravityMode' in settings &&\n    typeof settings.strongGravityMode !== 'boolean'\n  )\n    return {message: 'the `strongGravityMode` setting should be a boolean.'};\n\n  if (\n    'gravity' in settings &&\n    !(typeof settings.gravity === 'number' && settings.gravity >= 0)\n  )\n    return {message: 'the `gravity` setting should be a number >= 0.'};\n\n  if (\n    'slowDown' in settings &&\n    !(typeof settings.slowDown === 'number' || settings.slowDown >= 0)\n  )\n    return {message: 'the `slowDown` setting should be a number >= 0.'};\n\n  if (\n    'barnesHutOptimize' in settings &&\n    typeof settings.barnesHutOptimize !== 'boolean'\n  )\n    return {message: 'the `barnesHutOptimize` setting should be a boolean.'};\n\n  if (\n    'barnesHutTheta' in settings &&\n    !(\n      typeof settings.barnesHutTheta === 'number' &&\n      settings.barnesHutTheta >= 0\n    )\n  )\n    return {message: 'the `barnesHutTheta` setting should be a number >= 0.'};\n\n  return null;\n};\n\n/**\n * Function generating a flat matrix for both nodes & edges of the given graph.\n *\n * @param  {Graph}    graph         - Target graph.\n * @param  {function} getEdgeWeight - Edge weight getter function.\n * @return {object}                 - Both matrices.\n */\nexports.graphToByteArrays = function (graph, getEdgeWeight) {\n  var order = graph.order;\n  var size = graph.size;\n  var index = {};\n  var j;\n\n  // NOTE: float32 could lead to issues if edge array needs to index large\n  // number of nodes.\n  var NodeMatrix = new Float32Array(order * PPN);\n  var EdgeMatrix = new Float32Array(size * PPE);\n\n  // Iterate through nodes\n  j = 0;\n  graph.forEachNode(function (node, attr) {\n    // Node index\n    index[node] = j;\n\n    // Populating byte array\n    NodeMatrix[j] = attr.x;\n    NodeMatrix[j + 1] = attr.y;\n    NodeMatrix[j + 2] = 0; // dx\n    NodeMatrix[j + 3] = 0; // dy\n    NodeMatrix[j + 4] = 0; // old_dx\n    NodeMatrix[j + 5] = 0; // old_dy\n    NodeMatrix[j + 6] = 1; // mass\n    NodeMatrix[j + 7] = 1; // convergence\n    NodeMatrix[j + 8] = attr.size || 1;\n    NodeMatrix[j + 9] = attr.fixed ? 1 : 0;\n    j += PPN;\n  });\n\n  // Iterate through edges\n  j = 0;\n  graph.forEachEdge(function (edge, attr, source, target, sa, ta, u) {\n    var sj = index[source];\n    var tj = index[target];\n\n    var weight = getEdgeWeight(edge, attr, source, target, sa, ta, u);\n\n    // Incrementing mass to be a node's weighted degree\n    NodeMatrix[sj + 6] += weight;\n    NodeMatrix[tj + 6] += weight;\n\n    // Populating byte array\n    EdgeMatrix[j] = sj;\n    EdgeMatrix[j + 1] = tj;\n    EdgeMatrix[j + 2] = weight;\n    j += PPE;\n  });\n\n  return {\n    nodes: NodeMatrix,\n    edges: EdgeMatrix\n  };\n};\n\n/**\n * Function applying the layout back to the graph.\n *\n * @param {Graph}         graph         - Target graph.\n * @param {Float32Array}  NodeMatrix    - Node matrix.\n * @param {function|null} outputReducer - A node reducer.\n */\nexports.assignLayoutChanges = function (graph, NodeMatrix, outputReducer) {\n  var i = 0;\n\n  graph.updateEachNodeAttributes(function (node, attr) {\n    attr.x = NodeMatrix[i];\n    attr.y = NodeMatrix[i + 1];\n\n    i += PPN;\n\n    return outputReducer ? outputReducer(node, attr) : attr;\n  });\n};\n\n/**\n * Function reading the positions (only) from the graph, to write them in the matrix.\n *\n * @param {Graph}        graph      - Target graph.\n * @param {Float32Array} NodeMatrix - Node matrix.\n */\nexports.readGraphPositions = function (graph, NodeMatrix) {\n  var i = 0;\n\n  graph.forEachNode(function (node, attr) {\n    NodeMatrix[i] = attr.x;\n    NodeMatrix[i + 1] = attr.y;\n\n    i += PPN;\n  });\n};\n\n/**\n * Function collecting the layout positions.\n *\n * @param  {Graph}         graph         - Target graph.\n * @param  {Float32Array}  NodeMatrix    - Node matrix.\n * @param  {function|null} outputReducer - A nodes reducer.\n * @return {object}                      - Map to node positions.\n */\nexports.collectLayoutChanges = function (graph, NodeMatrix, outputReducer) {\n  var nodes = graph.nodes(),\n    positions = {};\n\n  for (var i = 0, j = 0, l = NodeMatrix.length; i < l; i += PPN) {\n    if (outputReducer) {\n      var newAttr = Object.assign({}, graph.getNodeAttributes(nodes[j]));\n      newAttr.x = NodeMatrix[i];\n      newAttr.y = NodeMatrix[i + 1];\n      newAttr = outputReducer(nodes[j], newAttr);\n      positions[nodes[j]] = {\n        x: newAttr.x,\n        y: newAttr.y\n      };\n    } else {\n      positions[nodes[j]] = {\n        x: NodeMatrix[i],\n        y: NodeMatrix[i + 1]\n      };\n    }\n\n    j++;\n  }\n\n  return positions;\n};\n\n/**\n * Function returning a web worker from the given function.\n *\n * @param  {function}  fn - Function for the worker.\n * @return {DOMString}\n */\nexports.createWorker = function createWorker(fn) {\n  var xURL = window.URL || window.webkitURL;\n  var code = fn.toString();\n  var objectUrl = xURL.createObjectURL(\n    new Blob(['(' + code + ').call(this);'], {type: 'text/javascript'})\n  );\n  var worker = new Worker(objectUrl);\n  xURL.revokeObjectURL(objectUrl);\n\n  return worker;\n};\n","/**\n * Graphology ForceAtlas2 Layout\n * ==============================\n *\n * Library endpoint.\n */\nvar isGraph = require('graphology-utils/is-graph');\nvar createEdgeWeightGetter =\n  require('graphology-utils/getters').createEdgeWeightGetter;\nvar iterate = require('./iterate.js');\nvar helpers = require('./helpers.js');\n\nvar DEFAULT_SETTINGS = require('./defaults.js');\n\n/**\n * Asbtract function used to run a certain number of iterations.\n *\n * @param  {boolean}       assign          - Whether to assign positions.\n * @param  {Graph}         graph           - Target graph.\n * @param  {object|number} params          - If number, params.iterations, else:\n * @param  {function}        getWeight     - Edge weight getter function.\n * @param  {number}          iterations    - Number of iterations.\n * @param  {function|null}   outputReducer - A node reducer\n * @param  {object}          [settings]    - Settings.\n * @return {object|undefined}\n */\nfunction abstractSynchronousLayout(assign, graph, params) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-layout-forceatlas2: the given graph is not a valid graphology instance.'\n    );\n\n  if (typeof params === 'number') params = {iterations: params};\n\n  var iterations = params.iterations;\n\n  if (typeof iterations !== 'number')\n    throw new Error(\n      'graphology-layout-forceatlas2: invalid number of iterations.'\n    );\n\n  if (iterations <= 0)\n    throw new Error(\n      'graphology-layout-forceatlas2: you should provide a positive number of iterations.'\n    );\n\n  var getEdgeWeight = createEdgeWeightGetter(\n    'getEdgeWeight' in params ? params.getEdgeWeight : 'weight'\n  ).fromEntry;\n\n  var outputReducer =\n    typeof params.outputReducer === 'function' ? params.outputReducer : null;\n\n  // Validating settings\n  var settings = helpers.assign({}, DEFAULT_SETTINGS, params.settings);\n  var validationError = helpers.validateSettings(settings);\n\n  if (validationError)\n    throw new Error(\n      'graphology-layout-forceatlas2: ' + validationError.message\n    );\n\n  // Building matrices\n  var matrices = helpers.graphToByteArrays(graph, getEdgeWeight);\n\n  var i;\n\n  // Iterating\n  for (i = 0; i < iterations; i++)\n    iterate(settings, matrices.nodes, matrices.edges);\n\n  // Applying\n  if (assign) {\n    helpers.assignLayoutChanges(graph, matrices.nodes, outputReducer);\n    return;\n  }\n\n  return helpers.collectLayoutChanges(graph, matrices.nodes);\n}\n\n/**\n * Function returning sane layout settings for the given graph.\n *\n * @param  {Graph|number} graph - Target graph or graph order.\n * @return {object}\n */\nfunction inferSettings(graph) {\n  var order = typeof graph === 'number' ? graph : graph.order;\n\n  return {\n    barnesHutOptimize: order > 2000,\n    strongGravityMode: true,\n    gravity: 0.05,\n    scalingRatio: 10,\n    slowDown: 1 + Math.log(order)\n  };\n}\n\n/**\n * Exporting.\n */\nvar synchronousLayout = abstractSynchronousLayout.bind(null, false);\nsynchronousLayout.assign = abstractSynchronousLayout.bind(null, true);\nsynchronousLayout.inferSettings = inferSettings;\n\nmodule.exports = synchronousLayout;\n","/* eslint no-constant-condition: 0 */\n/**\n * Graphology ForceAtlas2 Iteration\n * =================================\n *\n * Function used to perform a single iteration of the algorithm.\n */\n\n/**\n * Matrices properties accessors.\n */\nvar NODE_X = 0;\nvar NODE_Y = 1;\nvar NODE_DX = 2;\nvar NODE_DY = 3;\nvar NODE_OLD_DX = 4;\nvar NODE_OLD_DY = 5;\nvar NODE_MASS = 6;\nvar NODE_CONVERGENCE = 7;\nvar NODE_SIZE = 8;\nvar NODE_FIXED = 9;\n\nvar EDGE_SOURCE = 0;\nvar EDGE_TARGET = 1;\nvar EDGE_WEIGHT = 2;\n\nvar REGION_NODE = 0;\nvar REGION_CENTER_X = 1;\nvar REGION_CENTER_Y = 2;\nvar REGION_SIZE = 3;\nvar REGION_NEXT_SIBLING = 4;\nvar REGION_FIRST_CHILD = 5;\nvar REGION_MASS = 6;\nvar REGION_MASS_CENTER_X = 7;\nvar REGION_MASS_CENTER_Y = 8;\n\nvar SUBDIVISION_ATTEMPTS = 3;\n\n/**\n * Constants.\n */\nvar PPN = 10;\nvar PPE = 3;\nvar PPR = 9;\n\nvar MAX_FORCE = 10;\n\n/**\n * Function used to perform a single interation of the algorithm.\n *\n * @param  {object}       options    - Layout options.\n * @param  {Float32Array} NodeMatrix - Node data.\n * @param  {Float32Array} EdgeMatrix - Edge data.\n * @return {object}                  - Some metadata.\n */\nmodule.exports = function iterate(options, NodeMatrix, EdgeMatrix) {\n  // Initializing variables\n  var l, r, n, n1, n2, rn, e, w, g, s;\n\n  var order = NodeMatrix.length,\n    size = EdgeMatrix.length;\n\n  var adjustSizes = options.adjustSizes;\n\n  var thetaSquared = options.barnesHutTheta * options.barnesHutTheta;\n\n  var outboundAttCompensation, coefficient, xDist, yDist, ewc, distance, factor;\n\n  var RegionMatrix = [];\n\n  // 1) Initializing layout data\n  //-----------------------------\n\n  // Resetting positions & computing max values\n  for (n = 0; n < order; n += PPN) {\n    NodeMatrix[n + NODE_OLD_DX] = NodeMatrix[n + NODE_DX];\n    NodeMatrix[n + NODE_OLD_DY] = NodeMatrix[n + NODE_DY];\n    NodeMatrix[n + NODE_DX] = 0;\n    NodeMatrix[n + NODE_DY] = 0;\n  }\n\n  // If outbound attraction distribution, compensate\n  if (options.outboundAttractionDistribution) {\n    outboundAttCompensation = 0;\n    for (n = 0; n < order; n += PPN) {\n      outboundAttCompensation += NodeMatrix[n + NODE_MASS];\n    }\n\n    outboundAttCompensation /= order / PPN;\n  }\n\n  // 1.bis) Barnes-Hut computation\n  //------------------------------\n\n  if (options.barnesHutOptimize) {\n    // Setting up\n    var minX = Infinity,\n      maxX = -Infinity,\n      minY = Infinity,\n      maxY = -Infinity,\n      q,\n      q2,\n      subdivisionAttempts;\n\n    // Computing min and max values\n    for (n = 0; n < order; n += PPN) {\n      minX = Math.min(minX, NodeMatrix[n + NODE_X]);\n      maxX = Math.max(maxX, NodeMatrix[n + NODE_X]);\n      minY = Math.min(minY, NodeMatrix[n + NODE_Y]);\n      maxY = Math.max(maxY, NodeMatrix[n + NODE_Y]);\n    }\n\n    // squarify bounds, it's a quadtree\n    var dx = maxX - minX,\n      dy = maxY - minY;\n    if (dx > dy) {\n      minY -= (dx - dy) / 2;\n      maxY = minY + dx;\n    } else {\n      minX -= (dy - dx) / 2;\n      maxX = minX + dy;\n    }\n\n    // Build the Barnes Hut root region\n    RegionMatrix[0 + REGION_NODE] = -1;\n    RegionMatrix[0 + REGION_CENTER_X] = (minX + maxX) / 2;\n    RegionMatrix[0 + REGION_CENTER_Y] = (minY + maxY) / 2;\n    RegionMatrix[0 + REGION_SIZE] = Math.max(maxX - minX, maxY - minY);\n    RegionMatrix[0 + REGION_NEXT_SIBLING] = -1;\n    RegionMatrix[0 + REGION_FIRST_CHILD] = -1;\n    RegionMatrix[0 + REGION_MASS] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_X] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_Y] = 0;\n\n    // Add each node in the tree\n    l = 1;\n    for (n = 0; n < order; n += PPN) {\n      // Current region, starting with root\n      r = 0;\n      subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n\n      while (true) {\n        // Are there sub-regions?\n\n        // We look at first child index\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n          // There are sub-regions\n\n          // We just iterate to find a \"leaf\" of the tree\n          // that is an empty region or a region with a single node\n          // (see next case)\n\n          // Find the quadrant of n\n          if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n              // Top Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD];\n            } else {\n              // Bottom Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n            }\n          } else {\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n              // Top Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n            } else {\n              // Bottom Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n            }\n          }\n\n          // Update center of mass and mass (we only do it for non-leave regions)\n          RegionMatrix[r + REGION_MASS_CENTER_X] =\n            (RegionMatrix[r + REGION_MASS_CENTER_X] *\n              RegionMatrix[r + REGION_MASS] +\n              NodeMatrix[n + NODE_X] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS_CENTER_Y] =\n            (RegionMatrix[r + REGION_MASS_CENTER_Y] *\n              RegionMatrix[r + REGION_MASS] +\n              NodeMatrix[n + NODE_Y] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS] += NodeMatrix[n + NODE_MASS];\n\n          // Iterate on the right quadrant\n          r = q;\n          continue;\n        } else {\n          // There are no sub-regions: we are in a \"leaf\"\n\n          // Is there a node in this leave?\n          if (RegionMatrix[r + REGION_NODE] < 0) {\n            // There is no node in region:\n            // we record node n and go on\n            RegionMatrix[r + REGION_NODE] = n;\n            break;\n          } else {\n            // There is a node in this region\n\n            // We will need to create sub-regions, stick the two\n            // nodes (the old one r[0] and the new one n) in two\n            // subregions. If they fall in the same quadrant,\n            // we will iterate.\n\n            // Create sub-regions\n            RegionMatrix[r + REGION_FIRST_CHILD] = l * PPR;\n            w = RegionMatrix[r + REGION_SIZE] / 2; // new size (half)\n\n            // NOTE: we use screen coordinates\n            // from Top Left to Bottom Right\n\n            // Top Left sub-region\n            g = RegionMatrix[r + REGION_FIRST_CHILD];\n\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Left sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Top Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] =\n              RegionMatrix[r + REGION_NEXT_SIBLING];\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            l += 4;\n\n            // Now the goal is to find two different sub-regions\n            // for the two nodes: the one previously recorded (r[0])\n            // and the one we want to add (n)\n\n            // Find the quadrant of the old node\n            if (\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X] <\n              RegionMatrix[r + REGION_CENTER_X]\n            ) {\n              if (\n                NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] <\n                RegionMatrix[r + REGION_CENTER_Y]\n              ) {\n                // Top Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD];\n              } else {\n                // Bottom Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            } else {\n              if (\n                NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] <\n                RegionMatrix[r + REGION_CENTER_Y]\n              ) {\n                // Top Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              } else {\n                // Bottom Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            // We remove r[0] from the region r, add its mass to r and record it in q\n            RegionMatrix[r + REGION_MASS] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_MASS];\n            RegionMatrix[r + REGION_MASS_CENTER_X] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X];\n            RegionMatrix[r + REGION_MASS_CENTER_Y] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y];\n\n            RegionMatrix[q + REGION_NODE] = RegionMatrix[r + REGION_NODE];\n            RegionMatrix[r + REGION_NODE] = -1;\n\n            // Find the quadrant of n\n            if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n                // Top Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD];\n              } else {\n                // Bottom Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            } else {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n                // Top Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              } else {\n                // Bottom Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            if (q === q2) {\n              // If both nodes are in the same quadrant,\n              // we have to try it again on this quadrant\n              if (subdivisionAttempts--) {\n                r = q;\n                continue; // while\n              } else {\n                // we are out of precision here, and we cannot subdivide anymore\n                // but we have to break the loop anyway\n                subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n                break; // while\n              }\n            }\n\n            // If both quadrants are different, we record n\n            // in its quadrant\n            RegionMatrix[q2 + REGION_NODE] = n;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  // 2) Repulsion\n  //--------------\n  // NOTES: adjustSizes = antiCollision & scalingRatio = coefficient\n\n  if (options.barnesHutOptimize) {\n    coefficient = options.scalingRatio;\n\n    // Applying repulsion through regions\n    for (n = 0; n < order; n += PPN) {\n      // Computing leaf quad nodes iteration\n\n      r = 0; // Starting with root region\n      while (true) {\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n          // The region has sub-regions\n\n          // We run the Barnes Hut test to see if we are at the right distance\n          distance =\n            Math.pow(\n              NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X],\n              2\n            ) +\n            Math.pow(\n              NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y],\n              2\n            );\n\n          s = RegionMatrix[r + REGION_SIZE];\n\n          if ((4 * s * s) / distance < thetaSquared) {\n            // We treat the region as a single body, and we repulse\n\n            xDist =\n              NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X];\n            yDist =\n              NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y];\n\n            if (adjustSizes === true) {\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              } else if (distance < 0) {\n                factor =\n                  (-coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            } else {\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n\n            // When this is done, we iterate. We have to look at the next sibling.\n            r = RegionMatrix[r + REGION_NEXT_SIBLING];\n            if (r < 0) break; // No next sibling: we have finished the tree\n\n            continue;\n          } else {\n            // The region is too close and we have to look at sub-regions\n            r = RegionMatrix[r + REGION_FIRST_CHILD];\n            continue;\n          }\n        } else {\n          // The region has no sub-region\n          // If there is a node r[0] and it is not n, then repulse\n          rn = RegionMatrix[r + REGION_NODE];\n\n          if (rn >= 0 && rn !== n) {\n            xDist = NodeMatrix[n + NODE_X] - NodeMatrix[rn + NODE_X];\n            yDist = NodeMatrix[n + NODE_Y] - NodeMatrix[rn + NODE_Y];\n\n            distance = xDist * xDist + yDist * yDist;\n\n            if (adjustSizes === true) {\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              } else if (distance < 0) {\n                factor =\n                  (-coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            } else {\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n          }\n\n          // When this is done, we iterate. We have to look at the next sibling.\n          r = RegionMatrix[r + REGION_NEXT_SIBLING];\n\n          if (r < 0) break; // No next sibling: we have finished the tree\n\n          continue;\n        }\n      }\n    }\n  } else {\n    coefficient = options.scalingRatio;\n\n    // Square iteration\n    for (n1 = 0; n1 < order; n1 += PPN) {\n      for (n2 = 0; n2 < n1; n2 += PPN) {\n        // Common to both methods\n        xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n        yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n        if (adjustSizes === true) {\n          //-- Anticollision Linear Repulsion\n          distance =\n            Math.sqrt(xDist * xDist + yDist * yDist) -\n            NodeMatrix[n1 + NODE_SIZE] -\n            NodeMatrix[n2 + NODE_SIZE];\n\n          if (distance > 0) {\n            factor =\n              (coefficient *\n                NodeMatrix[n1 + NODE_MASS] *\n                NodeMatrix[n2 + NODE_MASS]) /\n              distance /\n              distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          } else if (distance < 0) {\n            factor =\n              100 *\n              coefficient *\n              NodeMatrix[n1 + NODE_MASS] *\n              NodeMatrix[n2 + NODE_MASS];\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        } else {\n          //-- Linear Repulsion\n          distance = Math.sqrt(xDist * xDist + yDist * yDist);\n\n          if (distance > 0) {\n            factor =\n              (coefficient *\n                NodeMatrix[n1 + NODE_MASS] *\n                NodeMatrix[n2 + NODE_MASS]) /\n              distance /\n              distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        }\n      }\n    }\n  }\n\n  // 3) Gravity\n  //------------\n  g = options.gravity / options.scalingRatio;\n  coefficient = options.scalingRatio;\n  for (n = 0; n < order; n += PPN) {\n    factor = 0;\n\n    // Common to both methods\n    xDist = NodeMatrix[n + NODE_X];\n    yDist = NodeMatrix[n + NODE_Y];\n    distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n\n    if (options.strongGravityMode) {\n      //-- Strong gravity\n      if (distance > 0) factor = coefficient * NodeMatrix[n + NODE_MASS] * g;\n    } else {\n      //-- Linear Anti-collision Repulsion n\n      if (distance > 0)\n        factor = (coefficient * NodeMatrix[n + NODE_MASS] * g) / distance;\n    }\n\n    // Updating node's dx and dy\n    NodeMatrix[n + NODE_DX] -= xDist * factor;\n    NodeMatrix[n + NODE_DY] -= yDist * factor;\n  }\n\n  // 4) Attraction\n  //---------------\n  coefficient =\n    1 * (options.outboundAttractionDistribution ? outboundAttCompensation : 1);\n\n  // TODO: simplify distance\n  // TODO: coefficient is always used as -c --> optimize?\n  for (e = 0; e < size; e += PPE) {\n    n1 = EdgeMatrix[e + EDGE_SOURCE];\n    n2 = EdgeMatrix[e + EDGE_TARGET];\n    w = EdgeMatrix[e + EDGE_WEIGHT];\n\n    // Edge weight influence\n    ewc = Math.pow(w, options.edgeWeightInfluence);\n\n    // Common measures\n    xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n    yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n    // Applying attraction to nodes\n    if (adjustSizes === true) {\n      distance =\n        Math.sqrt(xDist * xDist + yDist * yDist) -\n        NodeMatrix[n1 + NODE_SIZE] -\n        NodeMatrix[n2 + NODE_SIZE];\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n          //-- LinLog Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor =\n              (-coefficient * ewc * Math.log(1 + distance)) /\n              distance /\n              NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- LinLog Anti-collision Attraction\n          if (distance > 0) {\n            factor = (-coefficient * ewc * Math.log(1 + distance)) / distance;\n          }\n        }\n      } else {\n        if (options.outboundAttractionDistribution) {\n          //-- Linear Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor = (-coefficient * ewc) / NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- Linear Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc;\n          }\n        }\n      }\n    } else {\n      distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n          //-- LinLog Degree Distributed Attraction\n          if (distance > 0) {\n            factor =\n              (-coefficient * ewc * Math.log(1 + distance)) /\n              distance /\n              NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- LinLog Attraction\n          if (distance > 0)\n            factor = (-coefficient * ewc * Math.log(1 + distance)) / distance;\n        }\n      } else {\n        if (options.outboundAttractionDistribution) {\n          //-- Linear Attraction Mass Distributed\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = (-coefficient * ewc) / NodeMatrix[n1 + NODE_MASS];\n        } else {\n          //-- Linear Attraction\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = -coefficient * ewc;\n        }\n      }\n    }\n\n    // Updating nodes' dx and dy\n    // TODO: if condition or factor = 1?\n    if (distance > 0) {\n      // Updating nodes' dx and dy\n      NodeMatrix[n1 + NODE_DX] += xDist * factor;\n      NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n      NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n      NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n    }\n  }\n\n  // 5) Apply Forces\n  //-----------------\n  var force, swinging, traction, nodespeed, newX, newY;\n\n  // MATH: sqrt and square distances\n  if (adjustSizes === true) {\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n        force = Math.sqrt(\n          Math.pow(NodeMatrix[n + NODE_DX], 2) +\n            Math.pow(NodeMatrix[n + NODE_DY], 2)\n        );\n\n        if (force > MAX_FORCE) {\n          NodeMatrix[n + NODE_DX] =\n            (NodeMatrix[n + NODE_DX] * MAX_FORCE) / force;\n          NodeMatrix[n + NODE_DY] =\n            (NodeMatrix[n + NODE_DY] * MAX_FORCE) / force;\n        }\n\n        swinging =\n          NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction =\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n          ) / 2;\n\n        nodespeed = (0.1 * Math.log(1 + traction)) / (1 + Math.sqrt(swinging));\n\n        // Updating node's positon\n        newX =\n          NodeMatrix[n + NODE_X] +\n          NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY =\n          NodeMatrix[n + NODE_Y] +\n          NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  } else {\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n        swinging =\n          NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction =\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n          ) / 2;\n\n        nodespeed =\n          (NodeMatrix[n + NODE_CONVERGENCE] * Math.log(1 + traction)) /\n          (1 + Math.sqrt(swinging));\n\n        // Updating node convergence\n        NodeMatrix[n + NODE_CONVERGENCE] = Math.min(\n          1,\n          Math.sqrt(\n            (nodespeed *\n              (Math.pow(NodeMatrix[n + NODE_DX], 2) +\n                Math.pow(NodeMatrix[n + NODE_DY], 2))) /\n              (1 + Math.sqrt(swinging))\n          )\n        );\n\n        // Updating node's positon\n        newX =\n          NodeMatrix[n + NODE_X] +\n          NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY =\n          NodeMatrix[n + NODE_Y] +\n          NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  }\n\n  // We return the information about the layout (no need to return the matrices)\n  return {};\n};\n","/**\n * Graphology Weight Getter\n * =========================\n *\n * Function creating weight getters.\n */\nfunction coerceWeight(value) {\n  // Ensuring target value is a correct number\n  if (typeof value !== 'number' || isNaN(value)) return 1;\n\n  return value;\n}\n\nfunction createNodeValueGetter(nameOrFunction, defaultValue) {\n  var getter = {};\n\n  var coerceToDefault = function (v) {\n    if (typeof v === 'undefined') return defaultValue;\n\n    return v;\n  };\n\n  if (typeof defaultValue === 'function') coerceToDefault = defaultValue;\n\n  var get = function (attributes) {\n    return coerceToDefault(attributes[nameOrFunction]);\n  };\n\n  var returnDefault = function () {\n    return coerceToDefault(undefined);\n  };\n\n  if (typeof nameOrFunction === 'string') {\n    getter.fromAttributes = get;\n    getter.fromGraph = function (graph, node) {\n      return get(graph.getNodeAttributes(node));\n    };\n    getter.fromEntry = function (node, attributes) {\n      return get(attributes);\n    };\n  } else if (typeof nameOrFunction === 'function') {\n    getter.fromAttributes = function () {\n      throw new Error(\n        'graphology-utils/getters/createNodeValueGetter: irrelevant usage.'\n      );\n    };\n    getter.fromGraph = function (graph, node) {\n      return coerceToDefault(\n        nameOrFunction(node, graph.getNodeAttributes(node))\n      );\n    };\n    getter.fromEntry = function (node, attributes) {\n      return coerceToDefault(nameOrFunction(node, attributes));\n    };\n  } else {\n    getter.fromAttributes = returnDefault;\n    getter.fromGraph = returnDefault;\n    getter.fromEntry = returnDefault;\n  }\n\n  return getter;\n}\n\nfunction createEdgeValueGetter(nameOrFunction, defaultValue) {\n  var getter = {};\n\n  var coerceToDefault = function (v) {\n    if (typeof v === 'undefined') return defaultValue;\n\n    return v;\n  };\n\n  if (typeof defaultValue === 'function') coerceToDefault = defaultValue;\n\n  var get = function (attributes) {\n    return coerceToDefault(attributes[nameOrFunction]);\n  };\n\n  var returnDefault = function () {\n    return coerceToDefault(undefined);\n  };\n\n  if (typeof nameOrFunction === 'string') {\n    getter.fromAttributes = get;\n    getter.fromGraph = function (graph, edge) {\n      return get(graph.getEdgeAttributes(edge));\n    };\n    getter.fromEntry = function (edge, attributes) {\n      return get(attributes);\n    };\n    getter.fromPartialEntry = getter.fromEntry;\n    getter.fromMinimalEntry = getter.fromEntry;\n  } else if (typeof nameOrFunction === 'function') {\n    getter.fromAttributes = function () {\n      throw new Error(\n        'graphology-utils/getters/createEdgeValueGetter: irrelevant usage.'\n      );\n    };\n    getter.fromGraph = function (graph, edge) {\n      // TODO: we can do better, check #310\n      var extremities = graph.extremities(edge);\n      return coerceToDefault(\n        nameOrFunction(\n          edge,\n          graph.getEdgeAttributes(edge),\n          extremities[0],\n          extremities[1],\n          graph.getNodeAttributes(extremities[0]),\n          graph.getNodeAttributes(extremities[1]),\n          graph.isUndirected(edge)\n        )\n      );\n    };\n    getter.fromEntry = function (e, a, s, t, sa, ta, u) {\n      return coerceToDefault(nameOrFunction(e, a, s, t, sa, ta, u));\n    };\n    getter.fromPartialEntry = function (e, a, s, t) {\n      return coerceToDefault(nameOrFunction(e, a, s, t));\n    };\n    getter.fromMinimalEntry = function (e, a) {\n      return coerceToDefault(nameOrFunction(e, a));\n    };\n  } else {\n    getter.fromAttributes = returnDefault;\n    getter.fromGraph = returnDefault;\n    getter.fromEntry = returnDefault;\n    getter.fromMinimalEntry = returnDefault;\n  }\n\n  return getter;\n}\n\nexports.createNodeValueGetter = createNodeValueGetter;\nexports.createEdgeValueGetter = createEdgeValueGetter;\nexports.createEdgeWeightGetter = function (name) {\n  return createEdgeValueGetter(name, coerceWeight);\n};\n","/**\n * Graphology isGraph\n * ===================\n *\n * Very simple function aiming at ensuring the given variable is a\n * graphology instance.\n */\n\n/**\n * Checking the value is a graphology instance.\n *\n * @param  {any}     value - Target value.\n * @return {boolean}\n */\nmodule.exports = function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function' &&\n    typeof value.multi === 'boolean'\n  );\n};\n","/* @license\nPapa Parse\nv5.5.1\nhttps://github.com/mholt/PapaParse\nLicense: MIT\n*/\n((e,t)=>{\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof module&&\"undefined\"!=typeof exports?module.exports=t():e.Papa=t()})(this,function r(){var n=\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:void 0!==n?n:{};var d,s=!n.document&&!!n.postMessage,a=n.IS_PAPA_WORKER||!1,o={},h=0,v={};function u(e){this._handle=null,this._finished=!1,this._completed=!1,this._halted=!1,this._input=null,this._baseIndex=0,this._partialLine=\"\",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},function(e){var t=w(e);t.chunkSize=parseInt(t.chunkSize),e.step||e.chunk||(t.chunkSize=null);this._handle=new i(t),(this._handle.streamer=this)._config=t}.call(this,e),this.parseChunk=function(t,e){var i=parseInt(this._config.skipFirstNLines)||0;if(this.isFirstChunk&&0<i){let e=this._config.newline;e||(r=this._config.quoteChar||'\"',e=this._handle.guessLineEndings(t,r)),t=[...t.split(e).slice(i)].join(e)}this.isFirstChunk&&P(this._config.beforeFirstChunk)&&void 0!==(r=this._config.beforeFirstChunk(t))&&(t=r),this.isFirstChunk=!1,this._halted=!1;var i=this._partialLine+t,r=(this._partialLine=\"\",this._handle.parse(i,this._baseIndex,!this._finished));if(!this._handle.paused()&&!this._handle.aborted()){t=r.meta.cursor,i=(this._finished||(this._partialLine=i.substring(t-this._baseIndex),this._baseIndex=t),r&&r.data&&(this._rowCount+=r.data.length),this._finished||this._config.preview&&this._rowCount>=this._config.preview);if(a)n.postMessage({results:r,workerId:v.WORKER_ID,finished:i});else if(P(this._config.chunk)&&!e){if(this._config.chunk(r,this._handle),this._handle.paused()||this._handle.aborted())return void(this._halted=!0);this._completeResults=r=void 0}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(r.data),this._completeResults.errors=this._completeResults.errors.concat(r.errors),this._completeResults.meta=r.meta),this._completed||!i||!P(this._config.complete)||r&&r.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),i||r&&r.meta.paused||this._nextChunk(),r}this._halted=!0},this._sendError=function(e){P(this._config.error)?this._config.error(e):a&&this._config.error&&n.postMessage({workerId:v.WORKER_ID,error:e,finished:!1})}}function f(e){var r;(e=e||{}).chunkSize||(e.chunkSize=v.RemoteChunkSize),u.call(this,e),this._nextChunk=s?function(){this._readChunk(),this._chunkLoaded()}:function(){this._readChunk()},this.stream=function(e){this._input=e,this._nextChunk()},this._readChunk=function(){if(this._finished)this._chunkLoaded();else{if(r=new XMLHttpRequest,this._config.withCredentials&&(r.withCredentials=this._config.withCredentials),s||(r.onload=y(this._chunkLoaded,this),r.onerror=y(this._chunkError,this)),r.open(this._config.downloadRequestBody?\"POST\":\"GET\",this._input,!s),this._config.downloadRequestHeaders){var e,t=this._config.downloadRequestHeaders;for(e in t)r.setRequestHeader(e,t[e])}var i;this._config.chunkSize&&(i=this._start+this._config.chunkSize-1,r.setRequestHeader(\"Range\",\"bytes=\"+this._start+\"-\"+i));try{r.send(this._config.downloadRequestBody)}catch(e){this._chunkError(e.message)}s&&0===r.status&&this._chunkError()}},this._chunkLoaded=function(){4===r.readyState&&(r.status<200||400<=r.status?this._chunkError():(this._start+=this._config.chunkSize||r.responseText.length,this._finished=!this._config.chunkSize||this._start>=(e=>null!==(e=e.getResponseHeader(\"Content-Range\"))?parseInt(e.substring(e.lastIndexOf(\"/\")+1)):-1)(r),this.parseChunk(r.responseText)))},this._chunkError=function(e){e=r.statusText||e;this._sendError(new Error(e))}}function l(e){(e=e||{}).chunkSize||(e.chunkSize=v.LocalChunkSize),u.call(this,e);var i,r,n=\"undefined\"!=typeof FileReader;this.stream=function(e){this._input=e,r=e.slice||e.webkitSlice||e.mozSlice,n?((i=new FileReader).onload=y(this._chunkLoaded,this),i.onerror=y(this._chunkError,this)):i=new FileReaderSync,this._nextChunk()},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk()},this._readChunk=function(){var e=this._input,t=(this._config.chunkSize&&(t=Math.min(this._start+this._config.chunkSize,this._input.size),e=r.call(e,this._start,t)),i.readAsText(e,this._config.encoding));n||this._chunkLoaded({target:{result:t}})},this._chunkLoaded=function(e){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(e.target.result)},this._chunkError=function(){this._sendError(i.error)}}function c(e){var i;u.call(this,e=e||{}),this.stream=function(e){return i=e,this._nextChunk()},this._nextChunk=function(){var e,t;if(!this._finished)return e=this._config.chunkSize,i=e?(t=i.substring(0,e),i.substring(e)):(t=i,\"\"),this._finished=!i,this.parseChunk(t)}}function p(e){u.call(this,e=e||{});var t=[],i=!0,r=!1;this.pause=function(){u.prototype.pause.apply(this,arguments),this._input.pause()},this.resume=function(){u.prototype.resume.apply(this,arguments),this._input.resume()},this.stream=function(e){this._input=e,this._input.on(\"data\",this._streamData),this._input.on(\"end\",this._streamEnd),this._input.on(\"error\",this._streamError)},this._checkIsFinished=function(){r&&1===t.length&&(this._finished=!0)},this._nextChunk=function(){this._checkIsFinished(),t.length?this.parseChunk(t.shift()):i=!0},this._streamData=y(function(e){try{t.push(\"string\"==typeof e?e:e.toString(this._config.encoding)),i&&(i=!1,this._checkIsFinished(),this.parseChunk(t.shift()))}catch(e){this._streamError(e)}},this),this._streamError=y(function(e){this._streamCleanUp(),this._sendError(e)},this),this._streamEnd=y(function(){this._streamCleanUp(),r=!0,this._streamData(\"\")},this),this._streamCleanUp=y(function(){this._input.removeListener(\"data\",this._streamData),this._input.removeListener(\"end\",this._streamEnd),this._input.removeListener(\"error\",this._streamError)},this)}function i(m){var n,s,a,t,o=Math.pow(2,53),h=-o,u=/^\\s*-?(\\d+\\.?|\\.\\d+|\\d+\\.\\d+)([eE][-+]?\\d+)?\\s*$/,d=/^((\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z)))$/,i=this,r=0,f=0,l=!1,e=!1,c=[],p={data:[],errors:[],meta:{}};function y(e){return\"greedy\"===m.skipEmptyLines?\"\"===e.join(\"\").trim():1===e.length&&0===e[0].length}function g(){if(p&&a&&(k(\"Delimiter\",\"UndetectableDelimiter\",\"Unable to auto-detect delimiting character; defaulted to '\"+v.DefaultDelimiter+\"'\"),a=!1),m.skipEmptyLines&&(p.data=p.data.filter(function(e){return!y(e)})),_()){if(p)if(Array.isArray(p.data[0])){for(var e=0;_()&&e<p.data.length;e++)p.data[e].forEach(t);p.data.splice(0,1)}else p.data.forEach(t);function t(e,t){P(m.transformHeader)&&(e=m.transformHeader(e,t)),c.push(e)}}function i(e,t){for(var i=m.header?{}:[],r=0;r<e.length;r++){var n=r,s=e[r],s=((e,t)=>(e=>(m.dynamicTypingFunction&&void 0===m.dynamicTyping[e]&&(m.dynamicTyping[e]=m.dynamicTypingFunction(e)),!0===(m.dynamicTyping[e]||m.dynamicTyping)))(e)?\"true\"===t||\"TRUE\"===t||\"false\"!==t&&\"FALSE\"!==t&&((e=>{if(u.test(e)){e=parseFloat(e);if(h<e&&e<o)return 1}})(t)?parseFloat(t):d.test(t)?new Date(t):\"\"===t?null:t):t)(n=m.header?r>=c.length?\"__parsed_extra\":c[r]:n,s=m.transform?m.transform(s,n):s);\"__parsed_extra\"===n?(i[n]=i[n]||[],i[n].push(s)):i[n]=s}return m.header&&(r>c.length?k(\"FieldMismatch\",\"TooManyFields\",\"Too many fields: expected \"+c.length+\" fields but parsed \"+r,f+t):r<c.length&&k(\"FieldMismatch\",\"TooFewFields\",\"Too few fields: expected \"+c.length+\" fields but parsed \"+r,f+t)),i}var r;p&&(m.header||m.dynamicTyping||m.transform)&&(r=1,!p.data.length||Array.isArray(p.data[0])?(p.data=p.data.map(i),r=p.data.length):p.data=i(p.data,0),m.header&&p.meta&&(p.meta.fields=c),f+=r)}function _(){return m.header&&0===c.length}function k(e,t,i,r){e={type:e,code:t,message:i};void 0!==r&&(e.row=r),p.errors.push(e)}P(m.step)&&(t=m.step,m.step=function(e){p=e,_()?g():(g(),0!==p.data.length&&(r+=e.data.length,m.preview&&r>m.preview?s.abort():(p.data=p.data[0],t(p,i))))}),this.parse=function(e,t,i){var r=m.quoteChar||'\"',r=(m.newline||(m.newline=this.guessLineEndings(e,r)),a=!1,m.delimiter?P(m.delimiter)&&(m.delimiter=m.delimiter(e),p.meta.delimiter=m.delimiter):((r=((e,t,i,r,n)=>{var s,a,o,h;n=n||[\",\",\"\\t\",\"|\",\";\",v.RECORD_SEP,v.UNIT_SEP];for(var u=0;u<n.length;u++){for(var d,f=n[u],l=0,c=0,p=0,g=(o=void 0,new E({comments:r,delimiter:f,newline:t,preview:10}).parse(e)),_=0;_<g.data.length;_++)i&&y(g.data[_])?p++:(d=g.data[_].length,c+=d,void 0===o?o=d:0<d&&(l+=Math.abs(d-o),o=d));0<g.data.length&&(c/=g.data.length-p),(void 0===a||l<=a)&&(void 0===h||h<c)&&1.99<c&&(a=l,s=f,h=c)}return{successful:!!(m.delimiter=s),bestDelimiter:s}})(e,m.newline,m.skipEmptyLines,m.comments,m.delimitersToGuess)).successful?m.delimiter=r.bestDelimiter:(a=!0,m.delimiter=v.DefaultDelimiter),p.meta.delimiter=m.delimiter),w(m));return m.preview&&m.header&&r.preview++,n=e,s=new E(r),p=s.parse(n,t,i),g(),l?{meta:{paused:!0}}:p||{meta:{paused:!1}}},this.paused=function(){return l},this.pause=function(){l=!0,s.abort(),n=P(m.chunk)?\"\":n.substring(s.getCharIndex())},this.resume=function(){i.streamer._halted?(l=!1,i.streamer.parseChunk(n,!0)):setTimeout(i.resume,3)},this.aborted=function(){return e},this.abort=function(){e=!0,s.abort(),p.meta.aborted=!0,P(m.complete)&&m.complete(p),n=\"\"},this.guessLineEndings=function(e,t){e=e.substring(0,1048576);var t=new RegExp(M(t)+\"([^]*?)\"+M(t),\"gm\"),i=(e=e.replace(t,\"\")).split(\"\\r\"),t=e.split(\"\\n\"),e=1<t.length&&t[0].length<i[0].length;if(1===i.length||e)return\"\\n\";for(var r=0,n=0;n<i.length;n++)\"\\n\"===i[n][0]&&r++;return r>=i.length/2?\"\\r\\n\":\"\\r\"}}function M(e){return e.replace(/[.*+?^${}()|[\\]\\\\]/g,\"\\\\$&\")}function E(C){var S=(C=C||{}).delimiter,O=C.newline,x=C.comments,I=C.step,A=C.preview,T=C.fastMode,D=null,L=null==C.quoteChar?'\"':C.quoteChar,F=L;if(void 0!==C.escapeChar&&(F=C.escapeChar),(\"string\"!=typeof S||-1<v.BAD_DELIMITERS.indexOf(S))&&(S=\",\"),x===S)throw new Error(\"Comment character same as delimiter\");!0===x?x=\"#\":(\"string\"!=typeof x||-1<v.BAD_DELIMITERS.indexOf(x))&&(x=!1),\"\\n\"!==O&&\"\\r\"!==O&&\"\\r\\n\"!==O&&(O=\"\\n\");var j=0,z=!1;this.parse=function(i,t,r){if(\"string\"!=typeof i)throw new Error(\"Input must be a string\");var n=i.length,e=S.length,s=O.length,a=x.length,o=P(I),h=[],u=[],d=[],f=j=0;if(!i)return b();if(T||!1!==T&&-1===i.indexOf(L)){for(var l=i.split(O),c=0;c<l.length;c++){if(d=l[c],j+=d.length,c!==l.length-1)j+=O.length;else if(r)return b();if(!x||d.substring(0,a)!==x){if(o){if(h=[],k(d.split(S)),R(),z)return b()}else k(d.split(S));if(A&&A<=c)return h=h.slice(0,A),b(!0)}}return b()}for(var p=i.indexOf(S,j),g=i.indexOf(O,j),_=new RegExp(M(F)+M(L),\"g\"),m=i.indexOf(L,j);;)if(i[j]===L)for(m=j,j++;;){if(-1===(m=i.indexOf(L,m+1)))return r||u.push({type:\"Quotes\",code:\"MissingQuotes\",message:\"Quoted field unterminated\",row:h.length,index:j}),E();if(m===n-1)return E(i.substring(j,m).replace(_,L));if(L===F&&i[m+1]===F)m++;else if(L===F||0===m||i[m-1]!==F){-1!==p&&p<m+1&&(p=i.indexOf(S,m+1));var y=v(-1===(g=-1!==g&&g<m+1?i.indexOf(O,m+1):g)?p:Math.min(p,g));if(i.substr(m+1+y,e)===S){d.push(i.substring(j,m).replace(_,L)),i[j=m+1+y+e]!==L&&(m=i.indexOf(L,j)),p=i.indexOf(S,j),g=i.indexOf(O,j);break}y=v(g);if(i.substring(m+1+y,m+1+y+s)===O){if(d.push(i.substring(j,m).replace(_,L)),w(m+1+y+s),p=i.indexOf(S,j),m=i.indexOf(L,j),o&&(R(),z))return b();if(A&&h.length>=A)return b(!0);break}u.push({type:\"Quotes\",code:\"InvalidQuotes\",message:\"Trailing quote on quoted field is malformed\",row:h.length,index:j}),m++}}else if(x&&0===d.length&&i.substring(j,j+a)===x){if(-1===g)return b();j=g+s,g=i.indexOf(O,j),p=i.indexOf(S,j)}else if(-1!==p&&(p<g||-1===g))d.push(i.substring(j,p)),j=p+e,p=i.indexOf(S,j);else{if(-1===g)break;if(d.push(i.substring(j,g)),w(g+s),o&&(R(),z))return b();if(A&&h.length>=A)return b(!0)}return E();function k(e){h.push(e),f=j}function v(e){var t=0;return t=-1!==e&&(e=i.substring(m+1,e))&&\"\"===e.trim()?e.length:t}function E(e){return r||(void 0===e&&(e=i.substring(j)),d.push(e),j=n,k(d),o&&R()),b()}function w(e){j=e,k(d),d=[],g=i.indexOf(O,j)}function b(e){if(C.header&&!t&&h.length){var s=h[0],a={},o=new Set(s);let n=!1;for(let r=0;r<s.length;r++){let i=s[r];if(a[i=P(C.transformHeader)?C.transformHeader(i,r):i]){let e,t=a[i];for(;e=i+\"_\"+t,t++,o.has(e););o.add(e),s[r]=e,a[i]++,n=!0,(D=null===D?{}:D)[e]=i}else a[i]=1,s[r]=i;o.add(i)}n&&console.warn(\"Duplicate headers found and renamed.\")}return{data:h,errors:u,meta:{delimiter:S,linebreak:O,aborted:z,truncated:!!e,cursor:f+(t||0),renamedHeaders:D}}}function R(){I(b()),h=[],u=[]}},this.abort=function(){z=!0},this.getCharIndex=function(){return j}}function g(e){var t=e.data,i=o[t.workerId],r=!1;if(t.error)i.userError(t.error,t.file);else if(t.results&&t.results.data){var n={abort:function(){r=!0,_(t.workerId,{data:[],errors:[],meta:{aborted:!0}})},pause:m,resume:m};if(P(i.userStep)){for(var s=0;s<t.results.data.length&&(i.userStep({data:t.results.data[s],errors:t.results.errors,meta:t.results.meta},n),!r);s++);delete t.results}else P(i.userChunk)&&(i.userChunk(t.results,n,t.file),delete t.results)}t.finished&&!r&&_(t.workerId,t.results)}function _(e,t){var i=o[e];P(i.userComplete)&&i.userComplete(t),i.terminate(),delete o[e]}function m(){throw new Error(\"Not implemented.\")}function w(e){if(\"object\"!=typeof e||null===e)return e;var t,i=Array.isArray(e)?[]:{};for(t in e)i[t]=w(e[t]);return i}function y(e,t){return function(){e.apply(t,arguments)}}function P(e){return\"function\"==typeof e}return v.parse=function(e,t){var i=(t=t||{}).dynamicTyping||!1;P(i)&&(t.dynamicTypingFunction=i,i={});if(t.dynamicTyping=i,t.transform=!!P(t.transform)&&t.transform,!t.worker||!v.WORKERS_SUPPORTED)return i=null,v.NODE_STREAM_INPUT,\"string\"==typeof e?(e=(e=>65279!==e.charCodeAt(0)?e:e.slice(1))(e),i=new(t.download?f:c)(t)):!0===e.readable&&P(e.read)&&P(e.on)?i=new p(t):(n.File&&e instanceof File||e instanceof Object)&&(i=new l(t)),i.stream(e);(i=(()=>{var e;return!!v.WORKERS_SUPPORTED&&(e=(()=>{var e=n.URL||n.webkitURL||null,t=r.toString();return v.BLOB_URL||(v.BLOB_URL=e.createObjectURL(new Blob([\"var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; \",\"(\",t,\")();\"],{type:\"text/javascript\"})))})(),(e=new n.Worker(e)).onmessage=g,e.id=h++,o[e.id]=e)})()).userStep=t.step,i.userChunk=t.chunk,i.userComplete=t.complete,i.userError=t.error,t.step=P(t.step),t.chunk=P(t.chunk),t.complete=P(t.complete),t.error=P(t.error),delete t.worker,i.postMessage({input:e,config:t,workerId:i.id})},v.unparse=function(e,t){var n=!1,_=!0,m=\",\",y=\"\\r\\n\",s='\"',a=s+s,i=!1,r=null,o=!1,h=((()=>{if(\"object\"==typeof t){if(\"string\"!=typeof t.delimiter||v.BAD_DELIMITERS.filter(function(e){return-1!==t.delimiter.indexOf(e)}).length||(m=t.delimiter),\"boolean\"!=typeof t.quotes&&\"function\"!=typeof t.quotes&&!Array.isArray(t.quotes)||(n=t.quotes),\"boolean\"!=typeof t.skipEmptyLines&&\"string\"!=typeof t.skipEmptyLines||(i=t.skipEmptyLines),\"string\"==typeof t.newline&&(y=t.newline),\"string\"==typeof t.quoteChar&&(s=t.quoteChar),\"boolean\"==typeof t.header&&(_=t.header),Array.isArray(t.columns)){if(0===t.columns.length)throw new Error(\"Option columns is empty\");r=t.columns}void 0!==t.escapeChar&&(a=t.escapeChar+s),t.escapeFormulae instanceof RegExp?o=t.escapeFormulae:\"boolean\"==typeof t.escapeFormulae&&t.escapeFormulae&&(o=/^[=+\\-@\\t\\r].*$/)}})(),new RegExp(M(s),\"g\"));\"string\"==typeof e&&(e=JSON.parse(e));if(Array.isArray(e)){if(!e.length||Array.isArray(e[0]))return u(null,e,i);if(\"object\"==typeof e[0])return u(r||Object.keys(e[0]),e,i)}else if(\"object\"==typeof e)return\"string\"==typeof e.data&&(e.data=JSON.parse(e.data)),Array.isArray(e.data)&&(e.fields||(e.fields=e.meta&&e.meta.fields||r),e.fields||(e.fields=Array.isArray(e.data[0])?e.fields:\"object\"==typeof e.data[0]?Object.keys(e.data[0]):[]),Array.isArray(e.data[0])||\"object\"==typeof e.data[0]||(e.data=[e.data])),u(e.fields||[],e.data||[],i);throw new Error(\"Unable to serialize unrecognized input\");function u(e,t,i){var r=\"\",n=(\"string\"==typeof e&&(e=JSON.parse(e)),\"string\"==typeof t&&(t=JSON.parse(t)),Array.isArray(e)&&0<e.length),s=!Array.isArray(t[0]);if(n&&_){for(var a=0;a<e.length;a++)0<a&&(r+=m),r+=k(e[a],a);0<t.length&&(r+=y)}for(var o=0;o<t.length;o++){var h=(n?e:t[o]).length,u=!1,d=n?0===Object.keys(t[o]).length:0===t[o].length;if(i&&!n&&(u=\"greedy\"===i?\"\"===t[o].join(\"\").trim():1===t[o].length&&0===t[o][0].length),\"greedy\"===i&&n){for(var f=[],l=0;l<h;l++){var c=s?e[l]:l;f.push(t[o][c])}u=\"\"===f.join(\"\").trim()}if(!u){for(var p=0;p<h;p++){0<p&&!d&&(r+=m);var g=n&&s?e[p]:p;r+=k(t[o][g],p)}o<t.length-1&&(!i||0<h&&!d)&&(r+=y)}}return r}function k(e,t){var i,r;return null==e?\"\":e.constructor===Date?JSON.stringify(e).slice(1,25):(r=!1,o&&\"string\"==typeof e&&o.test(e)&&(e=\"'\"+e,r=!0),i=e.toString().replace(h,a),(r=r||!0===n||\"function\"==typeof n&&n(e,t)||Array.isArray(n)&&n[t]||((e,t)=>{for(var i=0;i<t.length;i++)if(-1<e.indexOf(t[i]))return!0;return!1})(i,v.BAD_DELIMITERS)||-1<i.indexOf(m)||\" \"===i.charAt(0)||\" \"===i.charAt(i.length-1))?s+i+s:i)}},v.RECORD_SEP=String.fromCharCode(30),v.UNIT_SEP=String.fromCharCode(31),v.BYTE_ORDER_MARK=\"\\ufeff\",v.BAD_DELIMITERS=[\"\\r\",\"\\n\",'\"',v.BYTE_ORDER_MARK],v.WORKERS_SUPPORTED=!s&&!!n.Worker,v.NODE_STREAM_INPUT=1,v.LocalChunkSize=10485760,v.RemoteChunkSize=5242880,v.DefaultDelimiter=\",\",v.Parser=E,v.ParserHandle=i,v.NetworkStreamer=f,v.FileStreamer=l,v.StringStreamer=c,v.ReadableStreamStreamer=p,n.jQuery&&((d=n.jQuery).fn.parse=function(o){var i=o.config||{},h=[];return this.each(function(e){if(!(\"INPUT\"===d(this).prop(\"tagName\").toUpperCase()&&\"file\"===d(this).attr(\"type\").toLowerCase()&&n.FileReader)||!this.files||0===this.files.length)return!0;for(var t=0;t<this.files.length;t++)h.push({file:this.files[t],inputElem:this,instanceConfig:d.extend({},i)})}),e(),this;function e(){if(0===h.length)P(o.complete)&&o.complete();else{var e,t,i,r,n=h[0];if(P(o.before)){var s=o.before(n.file,n.inputElem);if(\"object\"==typeof s){if(\"abort\"===s.action)return e=\"AbortError\",t=n.file,i=n.inputElem,r=s.reason,void(P(o.error)&&o.error({name:e},t,i,r));if(\"skip\"===s.action)return void u();\"object\"==typeof s.config&&(n.instanceConfig=d.extend(n.instanceConfig,s.config))}else if(\"skip\"===s)return void u()}var a=n.instanceConfig.complete;n.instanceConfig.complete=function(e){P(a)&&a(e,n.file,n.inputElem),u()},v.parse(n.file,n.instanceConfig)}}function u(){h.splice(0,1),e()}}),a&&(n.onmessage=function(e){e=e.data;void 0===v.WORKER_ID&&e&&(v.WORKER_ID=e.workerId);\"string\"==typeof e.input?n.postMessage({workerId:v.WORKER_ID,results:v.parse(e.input,e.config),finished:!0}):(n.File&&e.input instanceof File||e.input instanceof Object)&&(e=v.parse(e.input,e.config))&&n.postMessage({workerId:v.WORKER_ID,results:e,finished:!0})}),(f.prototype=Object.create(u.prototype)).constructor=f,(l.prototype=Object.create(u.prototype)).constructor=l,(c.prototype=Object.create(c.prototype)).constructor=c,(p.prototype=Object.create(u.prototype)).constructor=p,v});","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { EventEmitter } from 'events';\n\n/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Object.assign-like polyfill.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assignPolyfill() {\n  const target = arguments[0];\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i]) continue;\n\n    for (const k in arguments[i]) target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\nlet assign = assignPolyfill;\n\nif (typeof Object.assign === 'function') assign = Object.assign;\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nfunction getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData) return edge;\n\n  if (type === 'mixed') {\n    edge =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]);\n  } else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  } else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nfunction isPlainObject(value) {\n  // NOTE: as per https://github.com/graphology/graphology/issues/149\n  // this function has been loosened not to reject object instances\n  // coming from other JavaScript contexts. It has also been chosen\n  // not to improve it to avoid obvious false positives and avoid\n  // taking a performance hit. People should really use TypeScript\n  // if they want to avoid feeding subtly irrelvant attribute objects.\n  return typeof value === 'object' && value !== null;\n}\n\n/**\n * Checks whether the given object is empty.\n *\n * @param  {object}  o - Target Object.\n * @return {boolean}\n */\nfunction isEmpty(o) {\n  let k;\n\n  for (k in o) return false;\n\n  return true;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nfunction privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nfunction readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  } else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Returns whether the given object constitute valid hints.\n *\n * @param {object} hints - Target object.\n */\nfunction validateHints(hints) {\n  if (!isPlainObject(hints)) return false;\n\n  if (hints.attributes && !Array.isArray(hints.attributes)) return false;\n\n  return true;\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nfunction incrementalIdStartingFromRandomByte() {\n  let i = Math.floor(Math.random() * 256) & 0xff;\n\n  return () => {\n    return i++;\n  };\n}\n\n/**\n * Chains multiple iterators into a single iterator.\n *\n * @param {...Iterator} iterables\n * @returns {Iterator}\n */\nfunction chain() {\n  const iterables = arguments;\n  let current = null;\n  let i = -1;\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      let step = null;\n\n      do {\n        if (current === null) {\n          i++;\n          if (i >= iterables.length) return {done: true};\n          current = iterables[i][Symbol.iterator]();\n        }\n        step = current.next();\n        if (step.done) {\n          current = null;\n          continue;\n        }\n        break;\n        // eslint-disable-next-line no-constant-condition\n      } while (true);\n\n      return step;\n    }\n  };\n}\n\nfunction emptyIterator() {\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      return {done: true};\n    }\n  };\n}\n\n/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nclass GraphError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'GraphError';\n    this.message = message;\n  }\n}\n\nclass InvalidArgumentsGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(\n        this,\n        InvalidArgumentsGraphError.prototype.constructor\n      );\n  }\n}\n\nclass NotFoundGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nclass UsageGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n\n/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nfunction MixedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nMixedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.undirectedLoops = 0;\n  this.directedLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n};\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nfunction DirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nDirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nfunction UndirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nUndirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n/**\n * EdgeData class.\n *\n * @constructor\n * @param {boolean} undirected   - Whether the edge is undirected.\n * @param {string}  string       - The edge's key.\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nfunction EdgeData(undirected, key, source, target, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n  this.undirected = undirected;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n}\n\nEdgeData.prototype.attach = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  // Handling source\n  this.source[outKey][target] = this;\n\n  if (this.undirected && source === target) return;\n\n  // Handling target\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.attachMulti = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Handling source\n  const adj = this.source[outKey];\n  const head = adj[target];\n\n  if (typeof head === 'undefined') {\n    adj[target] = this;\n\n    // Self-loop optimization\n    if (!(this.undirected && source === target)) {\n      // Handling target\n      this.target[inKey][source] = this;\n    }\n\n    return;\n  }\n\n  // Prepending to doubly-linked list\n  head.previous = this;\n  this.next = head;\n\n  // Pointing to new head\n  // NOTE: use mutating swap later to avoid lookup?\n  adj[target] = this;\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.detach = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  delete this.source[outKey][target];\n\n  // No-op delete in case of undirected self-loop\n  delete this.target[inKey][source];\n};\n\nEdgeData.prototype.detachMulti = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Deleting from doubly-linked list\n  if (this.previous === undefined) {\n    // We are dealing with the head\n\n    // Should we delete the adjacency entry because it is now empty?\n    if (this.next === undefined) {\n      delete this.source[outKey][target];\n\n      // No-op delete in case of undirected self-loop\n      delete this.target[inKey][source];\n    } else {\n      // Detaching\n      this.next.previous = undefined;\n\n      // NOTE: could avoid the lookups by creating a #.become mutating method\n      this.source[outKey][target] = this.next;\n\n      // No-op delete in case of undirected self-loop\n      this.target[inKey][source] = this.next;\n    }\n  } else {\n    // We are dealing with another list node\n    this.previous.next = this.next;\n\n    // If not last\n    if (this.next !== undefined) {\n      this.next.previous = this.previous;\n    }\n  }\n};\n\n/**\n * Graphology Node Attributes methods\n * ===================================\n */\n\nconst NODE = 0;\nconst SOURCE = 1;\nconst TARGET = 2;\nconst OPPOSITE = 3;\n\nfunction findRelevantNodeData(\n  graph,\n  method,\n  mode,\n  nodeOrEdge,\n  nameOrEdge,\n  add1,\n  add2\n) {\n  let nodeData, edgeData, arg1, arg2;\n\n  nodeOrEdge = '' + nodeOrEdge;\n\n  if (mode === NODE) {\n    nodeData = graph._nodes.get(nodeOrEdge);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" node in the graph.`\n      );\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  } else if (mode === OPPOSITE) {\n    nameOrEdge = '' + nameOrEdge;\n\n    edgeData = graph._edges.get(nameOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nameOrEdge}\" edge in the graph.`\n      );\n\n    const source = edgeData.source.key;\n    const target = edgeData.target.key;\n\n    if (nodeOrEdge === source) {\n      nodeData = edgeData.target;\n    } else if (nodeOrEdge === target) {\n      nodeData = edgeData.source;\n    } else {\n      throw new NotFoundGraphError(\n        `Graph.${method}: the \"${nodeOrEdge}\" node is not attached to the \"${nameOrEdge}\" edge (${source}, ${target}).`\n      );\n    }\n\n    arg1 = add1;\n    arg2 = add2;\n  } else {\n    edgeData = graph._edges.get(nodeOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" edge in the graph.`\n      );\n\n    if (mode === SOURCE) {\n      nodeData = edgeData.source;\n    } else {\n      nodeData = edgeData.target;\n    }\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  }\n\n  return [nodeData, arg1, arg2];\n}\n\nfunction attachNodeAttributeGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes[name];\n  };\n}\n\nfunction attachNodeAttributesGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge) {\n    const [data] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge\n    );\n\n    return data.attributes;\n  };\n}\n\nfunction attachNodeAttributeChecker(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\nfunction attachNodeAttributeSetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, value] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    const attributes = data.attributes;\n    const value = updater(attributes[name]);\n\n    attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeRemover(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesReplacer(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesMerger(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst NODE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachNodeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachNodeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachNodeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachNodeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachNodeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachNodeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachNodeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachNodeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachNodeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nfunction attachNodeAttributesMethods(Graph) {\n  NODE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For nodes\n    attacher(Graph, name('Node'), NODE);\n\n    // For sources\n    attacher(Graph, name('Source'), SOURCE);\n\n    // For targets\n    attacher(Graph, name('Target'), TARGET);\n\n    // For opposites\n    attacher(Graph, name('Opposite'), OPPOSITE);\n  });\n}\n\n/**\n * Graphology Edge Attributes methods\n * ===================================\n */\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeGetter(Class, method, type) {\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributesGetter(Class, method, type) {\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 1) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributeChecker(Class, method, type) {\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeSetter(Class, method, type) {\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeUpdater(Class, method, type) {\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeRemover(Class, method, type) {\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesReplacer(Class, method, type) {\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesMerger(Class, method, type) {\n  /**\n   * Merge the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesUpdater(Class, method, type) {\n  /**\n   * Update the attributes of the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + updater;\n\n      updater = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst EDGE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachEdgeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachEdgeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachEdgeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachEdgeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachEdgeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachEdgeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachEdgeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachEdgeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachEdgeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nfunction attachEdgeAttributesMethods(Graph) {\n  EDGE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For edges\n    attacher(Graph, name('Edge'), 'mixed');\n\n    // For directed edges\n    attacher(Graph, name('DirectedEdge'), 'directed');\n\n    // For undirected edges\n    attacher(Graph, name('UndirectedEdge'), 'undirected');\n  });\n}\n\n/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function iterating over edges from the given object to match one of them.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(breakable, object, callback, avoid) {\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    const edgeData = object[k];\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n  }\n\n  return;\n}\n\nfunction forEachMulti(breakable, object, callback, avoid) {\n  let edgeData, source, target;\n\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    edgeData = object[k];\n\n    do {\n      source = edgeData.source;\n      target = edgeData.target;\n\n      shouldBreak = callback(\n        edgeData.key,\n        edgeData.attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes,\n        edgeData.undirected\n      );\n\n      if (breakable && shouldBreak) return edgeData.key;\n\n      edgeData = edgeData.next;\n    } while (edgeData !== undefined);\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object, avoid) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let edgeData;\n  let i = 0;\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      do {\n        if (!edgeData) {\n          if (i >= l) return {done: true};\n\n          const k = keys[i++];\n\n          if (k === avoid) {\n            edgeData = undefined;\n            continue;\n          }\n\n          edgeData = object[k];\n        } else {\n          edgeData = edgeData.next;\n        }\n      } while (!edgeData);\n\n      return {\n        done: false,\n        value: {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        }\n      };\n    }\n  };\n}\n\n/**\n * Function iterating over the egdes from the object at given key to match\n * one of them.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimple(breakable, object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  if (\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      sourceData.key,\n      targetData.key,\n      sourceData.attributes,\n      targetData.attributes,\n      edgeData.undirected\n    ) &&\n    breakable\n  )\n    return edgeData.key;\n}\n\nfunction forEachForKeyMulti(breakable, object, k, callback) {\n  let edgeData = object[k];\n\n  if (!edgeData) return;\n\n  let shouldBreak = false;\n\n  do {\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n\n    edgeData = edgeData.next;\n  } while (edgeData !== undefined);\n\n  return;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  let edgeData = object[k];\n\n  if (edgeData.next !== undefined) {\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        if (!edgeData) return {done: true};\n\n        const value = {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        };\n\n        edgeData = edgeData.next;\n\n        return {\n          done: false,\n          value\n        };\n      }\n    };\n  }\n\n  let done = false;\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      if (done === true) return {done: true};\n      done = true;\n      return {\n        done: false,\n        value: {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        }\n      };\n    }\n  };\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0) return [];\n\n  if (type === 'mixed' || type === graph.type) {\n    return Array.from(graph._edges.keys());\n  }\n\n  const size =\n    type === 'undirected' ? graph.undirectedSize : graph.directedSize;\n\n  const list = new Array(size),\n    mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  let i = 0;\n  let step, data;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (data.undirected === mask) list[i++] = data.key;\n  }\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback to match one of\n * them.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(breakable, graph, type, callback) {\n  if (graph.size === 0) return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  let shouldBreak = false;\n  const iterator = graph._edges.values();\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask) continue;\n\n    const {key, attributes, source, target} = data;\n\n    shouldBreak = callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected\n    );\n\n    if (breakable && shouldBreak) return key;\n  }\n\n  return;\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0) return emptyIterator();\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      let step, data;\n\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        step = iterator.next();\n\n        if (step.done) return step;\n\n        data = step.value;\n\n        if (shouldFilter && data.undirected !== mask) continue;\n\n        break;\n      }\n\n      const value = {\n        edge: data.key,\n        attributes: data.attributes,\n        source: data.source.key,\n        target: data.target.key,\n        sourceAttributes: data.source.attributes,\n        targetAttributes: data.target.attributes,\n        undirected: data.undirected\n      };\n\n      return {value, done: false};\n    }\n  };\n}\n\n/**\n * Function iterating over a node's edges using a callback to match one of them.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(\n  breakable,\n  multi,\n  type,\n  direction,\n  nodeData,\n  callback\n) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = fn(breakable, nodeData.in, callback);\n\n      if (breakable && found) return found;\n    }\n    if (direction !== 'in') {\n      found = fn(\n        breakable,\n        nodeData.out,\n        callback,\n        !direction ? nodeData.key : undefined\n      );\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    found = fn(breakable, nodeData.undirected, callback);\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {boolean} multi     - Whether the graph is multi or not.\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(multi, type, direction, nodeData) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForNode(false, multi, type, direction, nodeData, function (key) {\n    edges.push(key);\n  });\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = emptyIterator();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(\n        iterator,\n        createIterator(nodeData.out, !direction ? nodeData.key : undefined)\n      );\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function iterating over edges for the given path using a callback to match\n * one of them.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(\n  breakable,\n  type,\n  multi,\n  direction,\n  sourceData,\n  target,\n  callback\n) {\n  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {\n      found = fn(breakable, sourceData.in, target, callback);\n\n      if (breakable && found) return found;\n    }\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      (direction || sourceData.key !== target)\n    ) {\n      found = fn(breakable, sourceData.out, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') {\n      found = fn(breakable, sourceData.undirected, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, multi, direction, sourceData, target) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForPath(\n    false,\n    type,\n    multi,\n    direction,\n    sourceData,\n    target,\n    function (key) {\n      edges.push(key);\n    }\n  );\n\n  return edges;\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = emptyIterator();\n\n  if (type !== 'undirected') {\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out &&\n      (direction || sourceData.key !== target)\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(\n        iterator,\n        createIteratorForKey(sourceData.undirected, target)\n      );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length) return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(false, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        false,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        false,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function mapping the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Map all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Map all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Map the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    let result;\n\n    // We know the result length beforehand\n    if (args.length === 0) {\n      let length = 0;\n\n      if (type !== 'directed') length += this.undirectedSize;\n      if (type !== 'undirected') length += this.directedSize;\n\n      result = new Array(length);\n\n      let i = 0;\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result[i++] = callback(e, ea, s, t, sa, ta, u);\n      });\n    }\n\n    // We don't know the result length beforehand\n    // TODO: we can in some instances of simple graphs, knowing degree\n    else {\n      result = [];\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result.push(callback(e, ea, s, t, sa, ta, u));\n      });\n    }\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function filtering the graph's relevant edges using the provided predicate\n   * function.\n   *\n   * Arity 1: Filter all the relevant edges.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 2: Filter all of a node's relevant edges.\n   * @param  {any}      node      - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 3: Filter the relevant edges across the given path.\n   * @param  {any}      source    - Source node.\n   * @param  {any}      target    - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    const result = [];\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      if (callback(e, ea, s, t, sa, ta, u)) result.push(e);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function reducing the graph's relevant edges using the provided accumulator\n   * function.\n   *\n   * Arity 1: Reduce all the relevant edges.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 2: Reduce all of a node's relevant edges.\n   * @param  {any}      node         - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 3: Reduce the relevant edges across the given path.\n   * @param  {any}      source       - Source node.\n   * @param  {any}      target       - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function () {\n    let args = Array.prototype.slice.call(arguments);\n\n    if (args.length < 2 || args.length > 4) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: invalid number of arguments (expecting 2, 3 or 4 and got ${args.length}).`\n      );\n    }\n\n    if (\n      typeof args[args.length - 1] === 'function' &&\n      typeof args[args.length - 2] !== 'function'\n    ) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n    }\n\n    let callback;\n    let initialValue;\n\n    if (args.length === 2) {\n      callback = args[0];\n      initialValue = args[1];\n      args = [];\n    } else if (args.length === 3) {\n      callback = args[1];\n      initialValue = args[2];\n      args = [args[0]];\n    } else if (args.length === 4) {\n      callback = args[2];\n      initialValue = args[3];\n      args = [args[0], args[1]];\n    }\n\n    let accumulator = initialValue;\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      accumulator = callback(accumulator, e, ea, s, t, sa, ta, u);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable edge callback iterator method to the Graph\n * prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const findEdgeName = 'find' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges in order to match\n   * one of them using the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findEdgeName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return false;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(true, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        true,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        true,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${findEdgeName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether any one of them matches the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[someName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether all of them matche the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[everyName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return !callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeIteratorCreator(Class, description) {\n  const {name: originalName, type, direction} = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return emptyIterator();\n\n    if (!arguments.length) return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nfunction attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachFindEdge(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n\n/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Helpers.\n */\nfunction CompositeSetWrapper() {\n  this.A = null;\n  this.B = null;\n}\n\nCompositeSetWrapper.prototype.wrap = function (set) {\n  if (this.A === null) this.A = set;\n  else if (this.B === null) this.B = set;\n};\n\nCompositeSetWrapper.prototype.has = function (key) {\n  if (this.A !== null && key in this.A) return true;\n  if (this.B !== null && key in this.B) return true;\n  return false;\n};\n\n/**\n * Function iterating over the given node's relevant neighbors to match\n * one of them using a predicated function.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObjectOnce(breakable, visited, nodeData, object, callback) {\n  for (const k in object) {\n    const edgeData = object[k];\n\n    const sourceData = edgeData.source;\n    const targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited && visited.has(neighborData.key)) continue;\n\n    const shouldBreak = callback(neighborData.key, neighborData.attributes);\n\n    if (breakable && shouldBreak) return neighborData.key;\n  }\n\n  return;\n}\n\nfunction forEachNeighbor(breakable, type, direction, nodeData, callback) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.undirected,\n        callback\n      );\n\n    if (typeof direction === 'string')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData[direction],\n        callback\n      );\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.in,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.in);\n    }\n    if (direction !== 'in') {\n      found = forEachInObjectOnce(\n        breakable,\n        visited,\n        nodeData,\n        nodeData.out,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    found = forEachInObjectOnce(\n      breakable,\n      visited,\n      nodeData,\n      nodeData.undirected,\n      callback\n    );\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected') return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string') return Object.keys(nodeData[direction]);\n  }\n\n  const neighbors = [];\n\n  forEachNeighbor(false, type, direction, nodeData, function (key) {\n    neighbors.push(key);\n  });\n\n  return neighbors;\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let i = 0;\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      let neighborData = null;\n\n      do {\n        if (i >= l) {\n          if (visited) visited.wrap(object);\n          return {done: true};\n        }\n\n        const edgeData = object[keys[i++]];\n\n        const sourceData = edgeData.source;\n        const targetData = edgeData.target;\n\n        neighborData = sourceData === nodeData ? targetData : sourceData;\n\n        if (visited && visited.has(neighborData.key)) {\n          neighborData = null;\n          continue;\n        }\n      } while (neighborData === null);\n\n      return {\n        done: false,\n        value: {neighbor: neighborData.key, attributes: neighborData.attributes}\n      };\n    }\n  };\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createDedupedObjectIterator(null, nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createDedupedObjectIterator(null, nodeData, nodeData[direction]);\n  }\n\n  let iterator = emptyIterator();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.in)\n      );\n    }\n    if (direction !== 'in') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.out)\n      );\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(\n      iterator,\n      createDedupedObjectIterator(visited, nodeData, nodeData.undirected)\n    );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain neighbors.\n   *\n   * @param  {any}   node   - Target node.\n   * @return {array} - The neighbors of neighbors.\n   *\n   * @throws {Error} - Will throw if node is not found in the graph.\n   */\n  Class.prototype[name] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${name}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborArrayForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${forEachName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighbor(\n      false,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function mapping the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function (node, callback) {\n    // TODO: optimize when size is known beforehand\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      result.push(callback(n, a));\n    });\n\n    return result;\n  };\n\n  /**\n   * Function filtering the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function (node, callback) {\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      if (callback(n, a)) result.push(n);\n    });\n\n    return result;\n  };\n\n  /**\n   * Function reducing the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function (node, callback, initialValue) {\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n\n    let accumulator = initialValue;\n\n    this[forEachName](node, (n, a) => {\n      accumulator = callback(accumulator, n, a);\n    });\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable neighbors callback iterator method to the\n * Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);\n\n  const findName = 'find' + capitalizedSingular;\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${findName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return forEachNeighbor(\n      true,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if any of them\n   * matches the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + capitalizedSingular;\n\n  Class.prototype[someName] = function (node, callback) {\n    const found = this[findName](node, callback);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if all of them\n   * matche the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + capitalizedSingular;\n\n  Class.prototype[everyName] = function (node, callback) {\n    const found = this[findName](node, (n, a) => {\n      return !callback(n, a);\n    });\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return emptyIterator();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nfunction attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachFindNeighbor(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n\n/**\n * Graphology Adjacency Iteration\n * ===============================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's adjacency.\n */\n\n/**\n * Function iterating over a simple graph's adjacency using a callback.\n *\n * @param {boolean}  breakable         - Can we break?\n * @param {boolean}  assymetric        - Whether to emit undirected edges only once.\n * @param {boolean}  disconnectedNodes - Whether to emit disconnected nodes.\n * @param {Graph}    graph             - Target Graph instance.\n * @param {callback} function          - Iteration callback.\n */\nfunction forEachAdjacency(\n  breakable,\n  assymetric,\n  disconnectedNodes,\n  graph,\n  callback\n) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    let hasEdges = false;\n\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        if (assymetric && sourceData.key > neighbor) continue;\n\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          if (targetData.key !== neighbor) targetData = edgeData.source;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (disconnectedNodes && !hasEdges) {\n      shouldBreak = callback(\n        sourceData.key,\n        null,\n        sourceData.attributes,\n        null,\n        null,\n        null,\n        null\n      );\n\n      if (breakable && shouldBreak) return null;\n    }\n  }\n\n  return;\n}\n\n/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used by the graph serialization schemes.\n */\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nfunction serializeNode(key, data) {\n  const serialized = {key};\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {string} type - The graph's type.\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nfunction serializeEdge(type, key, data) {\n  const serialized = {\n    key,\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  if (type === 'mixed' && data.undirected) serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nfunction validateSerializedNode(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.'\n    );\n\n  if (!('key' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized node is missing its key.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nfunction validateSerializedEdge(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.'\n    );\n\n  if (!('source' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its source.'\n    );\n\n  if (!('target' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its target.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n\n  if ('undirected' in value && typeof value.undirected !== 'boolean')\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.'\n    );\n}\n\n/* eslint no-nested-ternary: 0 */\n\n/**\n * Constants.\n */\nconst INSTANCE_ID = incrementalIdStartingFromRandomByte();\n\n/**\n * Enums.\n */\nconst TYPES = new Set(['directed', 'undirected', 'mixed']);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add a node to the given graph\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {any}     node            - The node's key.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {NodeData}                - Created node data.\n */\nfunction addNode(graph, node, attributes) {\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // String coercion\n  node = '' + node;\n  attributes = attributes || {};\n\n  if (graph._nodes.has(node))\n    throw new UsageGraphError(\n      `Graph.addNode: the \"${node}\" node already exist in the graph.`\n    );\n\n  const data = new graph.NodeDataClass(node, attributes);\n\n  // Adding the node to internal register\n  graph._nodes.set(node, data);\n\n  // Emitting\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Same as the above but without sanity checks because we call this in contexts\n * where necessary checks were already done.\n */\nfunction unsafeAddNode(graph, node, attributes) {\n  const data = new graph.NodeDataClass(node, attributes);\n\n  graph._nodes.set(node, data);\n\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  const sourceData = graph._nodes.get(source),\n    targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: source node \"${source}\" not found.`\n    );\n\n  if (!targetData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: target node \"${target}\" not found.`\n    );\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (undirected\n      ? typeof sourceData.undirected[target] !== 'undefined'\n      : typeof sourceData.out[target] !== 'undefined')\n  ) {\n    throw new UsageGraphError(\n      `Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`\n    );\n  }\n\n  // Storing some data\n  const edgeData = new EdgeData(\n    undirected,\n    edge,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @param  {boolean} [asUpdater]       - Are we updating or merging?\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes,\n  asUpdater\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes) {\n    if (asUpdater) {\n      if (typeof attributes !== 'function')\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid updater function. Expecting a function but got \"${attributes}\"`\n        );\n    } else {\n      if (!isPlainObject(attributes))\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n        );\n    }\n  }\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n\n  let updater;\n\n  if (asUpdater) {\n    updater = attributes;\n    attributes = undefined;\n  }\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  let sourceData = graph._nodes.get(source);\n  let targetData = graph._nodes.get(target);\n  let edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdgeData;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are consistent\n      if (edgeData.source.key !== source || edgeData.target.key !== target) {\n        // If source or target inconsistent\n        if (\n          !undirected ||\n          edgeData.source.key !== target ||\n          edgeData.target.key !== source\n        ) {\n          // If directed, or source/target aren't flipped\n          throw new UsageGraphError(\n            `Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (\"${edgeData.source.key}\", \"${edgeData.target.key}\").`\n          );\n        }\n      }\n\n      alreadyExistingEdgeData = edgeData;\n    }\n  }\n\n  // Here, we might have a source / target collision\n  if (!alreadyExistingEdgeData && !graph.multi && sourceData) {\n    alreadyExistingEdgeData = undirected\n      ? sourceData.undirected[target]\n      : sourceData.out[target];\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n    const info = [alreadyExistingEdgeData.key, false, false, false];\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (asUpdater ? !updater : !attributes) return info;\n\n    // Updating the attributes\n    if (asUpdater) {\n      const oldAttributes = alreadyExistingEdgeData.attributes;\n      alreadyExistingEdgeData.attributes = updater(oldAttributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'replace',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes\n      });\n    }\n\n    // Merging the attributes\n    else {\n      assign(alreadyExistingEdgeData.attributes, attributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'merge',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n        data: attributes\n      });\n    }\n\n    return info;\n  }\n\n  attributes = attributes || {};\n\n  if (asUpdater && updater) attributes = updater(attributes);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  let sourceWasAdded = false;\n  let targetWasAdded = false;\n\n  if (!sourceData) {\n    sourceData = unsafeAddNode(graph, source, {});\n    sourceWasAdded = true;\n\n    if (source === target) {\n      targetData = sourceData;\n      targetWasAdded = true;\n    }\n  }\n  if (!targetData) {\n    targetData = unsafeAddNode(graph, target, {});\n    targetWasAdded = true;\n  }\n\n  // Storing some data\n  edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return [edge, true, sourceWasAdded, targetWasAdded];\n}\n\n/**\n * Internal method used to drop an edge.\n *\n * @param  {Graph}    graph    - Target graph.\n * @param  {EdgeData} edgeData - Data of the edge to drop.\n */\nfunction dropEdgeFromData(graph, edgeData) {\n  // Dropping the edge from the register\n  graph._edges.delete(edgeData.key);\n\n  // Updating related degrees\n  const {source: sourceData, target: targetData, attributes} = edgeData;\n\n  const undirected = edgeData.undirected;\n\n  const isSelfLoop = sourceData === targetData;\n\n  if (undirected) {\n    sourceData.undirectedDegree--;\n    targetData.undirectedDegree--;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops--;\n      graph._undirectedSelfLoopCount--;\n    }\n  } else {\n    sourceData.outDegree--;\n    targetData.inDegree--;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops--;\n      graph._directedSelfLoopCount--;\n    }\n  }\n\n  // Clearing index\n  if (graph.multi) edgeData.detachMulti();\n  else edgeData.detach();\n\n  if (undirected) graph._undirectedSize--;\n  else graph._directedSize--;\n\n  // Emitting\n  graph.emit('edgeDropped', {\n    key: edgeData.key,\n    attributes,\n    source: sourceData.key,\n    target: targetData.key,\n    undirected\n  });\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nclass Graph extends EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`\n      );\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`\n      );\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`\n      );\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass =\n      options.type === 'mixed'\n        ? MixedNodeData\n        : options.type === 'directed'\n        ? DirectedNodeData\n        : UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Internal edge key generator\n\n    // NOTE: this internal generator produce keys that are strings\n    // composed of a weird prefix, an incremental instance id starting from\n    // a random byte and finally an internal instance incremental id.\n    // All this to avoid intra-frame and cross-frame adversarial inputs\n    // that can force a single #.addEdge call to degenerate into a O(n)\n    // available key search loop.\n\n    // It also ensures that automatically generated edge keys are unlikely\n    // to produce collisions with arbitrary keys given by users.\n    const instancePrefix = 'geid_' + INSTANCE_ID() + '_';\n    let edgeId = 0;\n\n    const edgeKeyGenerator = () => {\n      let availableEdgeKey;\n\n      do {\n        availableEdgeKey = instancePrefix + edgeId++;\n      } while (this._edges.has(availableEdgeKey));\n\n      return availableEdgeKey;\n    };\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_directedSelfLoopCount', 0);\n    privateProperty(this, '_undirectedSelfLoopCount', 0);\n    privateProperty(this, '_edgeKeyGenerator', edgeKeyGenerator);\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(\n      this,\n      'selfLoopCount',\n      () => this._directedSelfLoopCount + this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'directedSelfLoopCount',\n      () => this._directedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'undirectedSelfLoopCount',\n      () => this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n    readOnlyProperty(this, 'implementation', () => 'graphology');\n  }\n\n  _resetInstanceCounters() {\n    this._directedSize = 0;\n    this._undirectedSize = 0;\n    this._directedSelfLoopCount = 0;\n    this._undirectedSelfLoopCount = 0;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'undirected') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && !edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return nodeData.out.hasOwnProperty(target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'directed') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return nodeData.undirected.hasOwnProperty(target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return (\n        (typeof nodeData.out !== 'undefined' &&\n          nodeData.out.hasOwnProperty(target)) ||\n        (typeof nodeData.undirected !== 'undefined' &&\n          nodeData.undirected.hasOwnProperty(target))\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n    if (this.type === 'undirected') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n    if (this.type === 'directed') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning whether two nodes are directed neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areDirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areDirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in || neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are out neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are in neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in;\n  }\n\n  /**\n   * Method returning whether two nodes are undirected neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areUndirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areUndirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return false;\n\n    return neighbor in nodeData.undirected;\n  }\n\n  /**\n   * Method returning whether two nodes are neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in || neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are inbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are outbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree;\n  }\n\n  /**\n   * Method returning the given node's inbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's outbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's in degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree - nodeData.directedLoops;\n  }\n\n  /**\n   * Method returning the given node's out degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree - nodeData.directedLoops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree - nodeData.directedLoops * 2;\n  }\n\n  /**\n   * Method returning the given node's undirected degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree - nodeData.undirectedLoops * 2;\n  }\n\n  /**\n   * Method returning the given node's inbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n      loops += nodeData.directedLoops;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's outbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n      loops += nodeData.directedLoops;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n      loops += nodeData.directedLoops * 2;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.source: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.target: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.extremities: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return [edgeData.source.key, edgeData.target.key];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph or if the\n   *                   edge & node are not related.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.opposite: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    const source = data.source.key;\n    const target = data.target.key;\n\n    if (node === source) return target;\n    if (node === target) return source;\n\n    throw new NotFoundGraphError(\n      `Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`\n    );\n  }\n\n  /**\n   * Returns whether the given edge has the given node as extremity.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @param  {any}     node - The node's key.\n   * @return {boolean}      - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  hasExtremity(edge, node) {\n    edge = '' + edge;\n    node = '' + node;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.hasExtremity: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key === node || data.target.key === node;\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isUndirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isUndirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isDirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isDirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return !data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isSelfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isSelfLoop: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source === data.target;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    const nodeData = addNode(this, node, attributes);\n\n    return nodeData.key;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes) {\n        assign(data.attributes, attributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'merge',\n          key: node,\n          attributes: data.attributes,\n          data: attributes\n        });\n      }\n      return [node, false];\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to add a node if it does not exist in the graph or else to\n   * update its attributes using a function.\n   *\n   * @param  {any}      node      - The node.\n   * @param  {function} [updater] - Optional updater function.\n   * @return {any}                - The node.\n   */\n  updateNode(node, updater) {\n    if (updater && typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.updateNode: invalid updater function. Expecting a function but got \"${updater}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n\n    // If the node already exists, we update the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (updater) {\n        const oldAttributes = data.attributes;\n        data.attributes = updater(oldAttributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'replace',\n          key: node,\n          attributes: data.attributes\n        });\n      }\n      return [node, false];\n    }\n\n    const attributes = updater ? updater({}) : {};\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.dropNode: could not find the \"${node}\" node in the graph.`\n      );\n\n    let edgeData;\n\n    // Removing attached edges\n    // NOTE: we could be faster here, but this is such a pain to maintain\n    if (this.type !== 'undirected') {\n      for (const neighbor in nodeData.out) {\n        edgeData = nodeData.out[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n\n      for (const neighbor in nodeData.in) {\n        edgeData = nodeData.in[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (this.type !== 'directed') {\n      for (const neighbor in nodeData.undirected) {\n        edgeData = nodeData.undirected[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: nodeData.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0];\n      const target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`\n        );\n    } else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`\n        );\n    }\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single directed edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropDirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const edgeData = getMatchingEdge(this, source, target, 'directed');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropDirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single undirected edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropUndirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    const edgeData = getMatchingEdge(this, source, target, 'undirected');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropUndirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n    // Clearing structure index\n    const iterator = this._nodes.values();\n\n    let step;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      step.value.clear();\n    }\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttribute: updater should be a function.'\n      );\n\n    const value = this._attributes[name];\n\n    this._attributes[name] = updater(value);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.replaceAttributes: provided attributes are not a plain object.'\n      );\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.mergeAttributes: provided attributes are not a plain object.'\n      );\n\n    assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      attributes: this._attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method updating the graph's attributes.\n   *\n   * @param  {function} updater - Function used to update the attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given updater is not a function.\n   */\n  updateAttributes(updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttributes: provided updater is not a function.'\n      );\n\n    this._attributes = updater(this._attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'update',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to update each node's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachNodeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      nodeData.attributes = updater(nodeData.key, nodeData.attributes);\n    }\n\n    this.emit('eachNodeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**\n   * Method used to update each edge's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachEdgeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._edges.values();\n\n    let step, edgeData, sourceData, targetData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n      sourceData = edgeData.source;\n      targetData = edgeData.target;\n\n      edgeData.attributes = updater(\n        edgeData.key,\n        edgeData.attributes,\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.undirected\n      );\n    }\n\n    this.emit('eachEdgeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, false, this, callback);\n  }\n  forEachAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, true, this, callback);\n  }\n\n  /**\n   * Method iterating over the graph's assymetric adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAssymetricAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, false, this, callback);\n  }\n  forEachAssymetricAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, true, this, callback);\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    return Array.from(this._nodes.keys());\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      callback(nodeData.key, nodeData.attributes);\n    }\n  }\n\n  /**\n   * Method iterating attempting to find a node matching the given predicate\n   * function.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  findNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.findNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return nodeData.key;\n    }\n\n    return;\n  }\n\n  /**\n   * Method mapping nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  mapNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.mapNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = new Array(this.order);\n    let i = 0;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      result[i++] = callback(nodeData.key, nodeData.attributes);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method returning whether some node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  someNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.someNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether all node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  everyNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.everyNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (!callback(nodeData.key, nodeData.attributes)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Method filtering nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  filterNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.filterNodes: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = [];\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes))\n        result.push(nodeData.key);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method reducing nodes.\n   *\n   * @param  {function}  callback - Callback (accumulator, key, attributes).\n   */\n  reduceNodes(callback, initialValue) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: expecting a callback.'\n      );\n\n    if (arguments.length < 2)\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.'\n      );\n\n    let accumulator = initialValue;\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      accumulator = callback(accumulator, nodeData.key, nodeData.attributes);\n    }\n\n    return accumulator;\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const step = iterator.next();\n        if (step.done) return step;\n        const data = step.value;\n        return {\n          value: {node: data.key, attributes: data.attributes},\n          done: false\n        };\n      }\n    };\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(this.type, key, data);\n    });\n\n    return {\n      options: {\n        type: this.type,\n        multi: this.multi,\n        allowSelfLoops: this.allowSelfLoops\n      },\n      attributes: this.getAttributes(),\n      nodes,\n      edges\n    };\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n    // Importing a Graph instance directly\n    if (data instanceof Graph) {\n      // Nodes\n      data.forEachNode((n, a) => {\n        if (merge) this.mergeNode(n, a);\n        else this.addNode(n, a);\n      });\n\n      // Edges\n      data.forEachEdge((e, a, s, t, _sa, _ta, u) => {\n        if (merge) {\n          if (u) this.mergeUndirectedEdgeWithKey(e, s, t, a);\n          else this.mergeDirectedEdgeWithKey(e, s, t, a);\n        } else {\n          if (u) this.addUndirectedEdgeWithKey(e, s, t, a);\n          else this.addDirectedEdgeWithKey(e, s, t, a);\n        }\n      });\n\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError(\n        'Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.'\n      );\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid attributes. Expecting a plain object.'\n        );\n\n      if (merge) this.mergeAttributes(data.attributes);\n      else this.replaceAttributes(data.attributes);\n    }\n\n    let i, l, list, node, edge;\n\n    if (data.nodes) {\n      list = data.nodes;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid nodes. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        node = list[i];\n\n        // Validating\n        validateSerializedNode(node);\n\n        // Adding the node\n        const {key, attributes} = node;\n\n        if (merge) this.mergeNode(key, attributes);\n        else this.addNode(key, attributes);\n      }\n    }\n\n    if (data.edges) {\n      let undirectedByDefault = false;\n\n      if (this.type === 'undirected') {\n        undirectedByDefault = true;\n      }\n\n      list = data.edges;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid edges. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        edge = list[i];\n\n        // Validating\n        validateSerializedEdge(edge);\n\n        // Adding the edge\n        const {\n          source,\n          target,\n          attributes,\n          undirected = undirectedByDefault\n        } = edge;\n\n        let method;\n\n        if ('key' in edge) {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdgeWithKey\n              : this.mergeDirectedEdgeWithKey\n            : undirected\n            ? this.addUndirectedEdgeWithKey\n            : this.addDirectedEdgeWithKey;\n\n          method.call(this, edge.key, source, target, attributes);\n        } else {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdge\n              : this.mergeDirectedEdge\n            : undirected\n            ? this.addUndirectedEdge\n            : this.addDirectedEdge;\n\n          method.call(this, source, target, attributes);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    const graph = new Graph(assign({}, this._options, options));\n    graph.replaceAttributes(assign({}, this.getAttributes()));\n    return graph;\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = this.nullCopy(options);\n\n    this._nodes.forEach((nodeData, key) => {\n      const attributes = assign({}, nodeData.attributes);\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      nodeData = new graph.NodeDataClass(key, attributes);\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @param  {object} options - Upgrade options.\n   * @return {Graph}          - The copy.\n   */\n  copy(options) {\n    options = options || {};\n\n    if (\n      typeof options.type === 'string' &&\n      options.type !== this.type &&\n      options.type !== 'mixed'\n    )\n      throw new UsageGraphError(\n        `Graph.copy: cannot create an incompatible copy from \"${this.type}\" type to \"${options.type}\" because this would mean losing information about the current graph.`\n      );\n\n    if (\n      typeof options.multi === 'boolean' &&\n      options.multi !== this.multi &&\n      options.multi !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.'\n      );\n\n    if (\n      typeof options.allowSelfLoops === 'boolean' &&\n      options.allowSelfLoops !== this.allowSelfLoops &&\n      options.allowSelfLoops !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.'\n      );\n\n    const graph = this.emptyCopy(options);\n\n    const iterator = this._edges.values();\n\n    let step, edgeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      addEdge(\n        graph,\n        'copy',\n        false,\n        edgeData.undirected,\n        edgeData.key,\n        edgeData.source.key,\n        edgeData.target.key,\n        assign({}, edgeData.attributes)\n      );\n    }\n\n    return graph;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method returning [object Graph].\n   */\n  toString() {\n    return '[object Graph]';\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n      multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data.undirected ? '--' : '->';\n\n      let label = '';\n\n      let source = data.source.key;\n      let target = data.target.key;\n      let tmp;\n\n      if (data.undirected && source > target) {\n        tmp = source;\n        source = target;\n        target = tmp;\n      }\n\n      const desc = `(${source})${direction}(${target})`;\n\n      if (!key.startsWith('geid_')) {\n        label += `[${key}]: `;\n      } else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        } else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (\n        this.hasOwnProperty(k) &&\n        !EMITTER_PROPS.has(k) &&\n        typeof this[k] !== 'function' &&\n        typeof k !== 'symbol'\n      )\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] =\n    Graph.prototype.inspect;\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge', 'update'].forEach(verb => {\n    const name = method.name(verb);\n    const fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function (source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    } else {\n      Graph.prototype[name] = function (edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n  });\n});\n\n/**\n * Attributes-related.\n */\nattachNodeAttributesMethods(Graph);\nattachEdgeAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n\n/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function (data, options) {\n    // Merging given options with serialized ones\n    const finalOptions = assign({}, data.options, options);\n\n    const instance = new Class(finalOptions);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\n/**\n * Graphology ESM Endoint\n * =======================\n *\n * Endpoint for ESM modules consumers.\n */\n\nexport { DirectedGraph, Graph, InvalidArgumentsGraphError, MultiDirectedGraph, MultiGraph, MultiUndirectedGraph, NotFoundGraphError, UndirectedGraph, UsageGraphError, Graph as default };\n//# sourceMappingURL=graphology.mjs.map\n","// Import the CSS file for this page\r\nimport '../CSS/home.css';\r\n\r\nimport Sigma from \"sigma\";\r\nimport { Graph } from \"graphology\";\r\nimport { parse } from \"papaparse\";\r\nimport forceAtlas2 from \"graphology-layout-forceatlas2\"; // Import ForceAtlas2 layout\r\n\r\n// Create a graphology graph\r\nconst graph = new Graph();\r\n\r\n// Function to load and parse the CSV file\r\n\r\n/*\r\nfunction loadCSV(csvPath) {\r\n  fetch(csvPath)\r\n    .then((response) => response.text())\r\n    .then((csvData) => {\r\n      // Parse the CSV data\r\n      parse(csvData, {\r\n        header: true,\r\n        complete: function (results) {\r\n          const data = results.data;\r\n          console.log(\"Parsed CSV Data:\", data);\r\n\r\n          // Add nodes and edges from the CSV\r\n          data.forEach((row) => {\r\n            const edgeThickness = parseFloat(row.Value) || 1;\r\n            const targetlink = row.TargetLink;\r\n            const sourcelink = row.SourceLink;\r\n\r\n            // Add nodes with updated styling\r\n            if (!graph.hasNode(row.Source)) {\r\n              graph.addNode(row.Source, {\r\n                label: row.Source,\r\n                size: 15,\r\n                color: \"#1f77b4\", // Custom blue color\r\n                x: Math.random(),\r\n                y: Math.random(),\r\n                link: sourcelink,\r\n              });\r\n            }\r\n\r\n            if (!graph.hasNode(row.Target)) {\r\n              graph.addNode(row.Target, {\r\n                label: row.Target,\r\n                size: 15,\r\n                color: \"#ff7f0e\", // Orange color\r\n                x: Math.random(),\r\n                y: Math.random(),\r\n                link: targetlink,\r\n              });\r\n            }\r\n\r\n            // Add edges with styles\r\n            graph.addEdge(row.Source, row.Target, {\r\n              size: edgeThickness,\r\n              color: \"#888\", // Gray edges\r\n            });\r\n          });\r\n\r\n          graph.forEachNode((node, attributes) => {\r\n            console.log(\"Node: \", node, \"Attributes:\", attributes)\r\n          })\r\n\r\n          // Apply ForceAtlas2 layout\r\n          const layoutSettings = {\r\n            iterations: 10,\r\n            gravity: 5,\r\n            scalingRatio: 2,\r\n          };\r\n          forceAtlas2.assign(graph, layoutSettings);\r\n\r\n          console.log(\"Nodes in graph:\", graph.nodes());\r\n\r\n          // Render the graph using Sigma.js\r\n          const sigmaInstance = new Sigma(graph, document.getElementById(\"graph\"), {\r\n            // Set the label color for nodes (applied to all node labels)\r\n            labelColor: { attribute: \"labelColor\", color: \"white\" },\r\n            renderEdgeLabels: true, // Show edge labels\r\n          });\r\n\r\n          // Force a refresh to apply styles\r\n          sigmaInstance.refresh();\r\n\r\n          // Add event listener for node click\r\n          sigmaInstance.on(\"clickNode\", function (event) {\r\n            const nodeId = event.node;\r\n            const nodeData = graph.getNodeAttributes(nodeId);\r\n\r\n            console.log(\"Node data:\", nodeData);\r\n\r\n            if (nodeData.link) {\r\n              console.log(\"Link:\", nodeData.link);\r\n            }\r\n          });\r\n        },\r\n      });\r\n    })\r\n    .catch((error) => console.error(\"Error loading CSV file:\", error));\r\n\r\n\r\n}\r\n\r\n// Load the CSV file\r\nloadCSV(\"/assets/Links.csv\");\r\n*/"],"names":["ReflectOwnKeys","R","Reflect","ReflectApply","apply","target","receiver","args","Function","prototype","call","ownKeys","Object","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","value","EventEmitter","init","this","module","exports","once","emitter","name","Promise","resolve","reject","errorListener","err","removeListener","resolver","slice","arguments","eventTargetAgnosticAddListener","handler","on","addErrorHandlerIfEventEmitter","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","type","prepend","m","events","existing","warning","create","newListener","emit","unshift","push","length","warned","w","Error","String","count","console","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","Array","i","unwrapListeners","arrayClone","listenerCount","n","copy","flags","addEventListener","wrapListener","arg","removeEventListener","defineProperty","enumerable","get","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","error","er","message","context","len","listeners","addListener","prependListener","prependOnceListener","list","position","originalListener","shift","index","pop","spliceOne","off","removeAllListeners","key","keys","rawListeners","eventNames","linLogMode","outboundAttractionDistribution","adjustSizes","edgeWeightInfluence","scalingRatio","strongGravityMode","gravity","slowDown","barnesHutOptimize","barnesHutTheta","assign","k","l","objects","validateSettings","settings","graphToByteArrays","graph","getEdgeWeight","j","order","size","NodeMatrix","Float32Array","EdgeMatrix","forEachNode","node","attr","x","y","fixed","forEachEdge","edge","source","sa","ta","u","sj","tj","weight","nodes","edges","assignLayoutChanges","outputReducer","updateEachNodeAttributes","readGraphPositions","collectLayoutChanges","positions","newAttr","getNodeAttributes","createWorker","fn","xURL","window","URL","webkitURL","code","toString","objectUrl","createObjectURL","Blob","worker","Worker","revokeObjectURL","isGraph","createEdgeWeightGetter","iterate","helpers","DEFAULT_SETTINGS","abstractSynchronousLayout","params","iterations","fromEntry","validationError","matrices","synchronousLayout","inferSettings","Math","log","PPN","options","r","n1","n2","rn","e","g","s","outboundAttCompensation","coefficient","xDist","yDist","ewc","distance","factor","force","swinging","traction","nodespeed","newX","newY","thetaSquared","RegionMatrix","q","q2","subdivisionAttempts","minX","Infinity","maxX","minY","maxY","min","max","dx","dy","PPR","pow","sqrt","coerceWeight","nameOrFunction","defaultValue","getter","coerceToDefault","v","attributes","returnDefault","fromAttributes","fromGraph","getEdgeAttributes","fromPartialEntry","fromMinimalEntry","extremities","isUndirected","a","t","createEdgeValueGetter","addUndirectedEdgeWithKey","dropNode","multi","d","self","document","postMessage","IS_PAPA_WORKER","o","h","_handle","_finished","_completed","_halted","_input","_baseIndex","_partialLine","_rowCount","_start","_nextChunk","isFirstChunk","_completeResults","data","errors","meta","chunkSize","parseInt","step","chunk","streamer","_config","parseChunk","skipFirstNLines","newline","quoteChar","guessLineEndings","split","join","P","beforeFirstChunk","parse","paused","aborted","cursor","substring","preview","results","workerId","WORKER_ID","finished","complete","_sendError","f","RemoteChunkSize","_readChunk","_chunkLoaded","stream","XMLHttpRequest","withCredentials","onload","onerror","_chunkError","open","downloadRequestBody","downloadRequestHeaders","setRequestHeader","send","status","readyState","responseText","getResponseHeader","lastIndexOf","statusText","LocalChunkSize","FileReader","webkitSlice","mozSlice","FileReaderSync","readAsText","encoding","result","c","p","pause","resume","_streamData","_streamEnd","_streamError","_checkIsFinished","_streamCleanUp","skipEmptyLines","trim","DefaultDelimiter","filter","_","isArray","forEach","splice","transformHeader","header","dynamicTypingFunction","dynamicTyping","test","parseFloat","Date","transform","map","fields","row","abort","delimiter","RECORD_SEP","UNIT_SEP","E","comments","abs","successful","bestDelimiter","delimitersToGuess","getCharIndex","setTimeout","RegExp","M","replace","C","S","O","I","A","T","fastMode","D","L","F","escapeChar","BAD_DELIMITERS","indexOf","z","b","substr","Set","has","add","linebreak","truncated","renamedHeaders","userError","file","userStep","userChunk","userComplete","terminate","WORKERS_SUPPORTED","NODE_STREAM_INPUT","charCodeAt","download","readable","read","File","BLOB_URL","onmessage","id","input","config","unparse","quotes","columns","escapeFormulae","JSON","constructor","stringify","charAt","fromCharCode","BYTE_ORDER_MARK","Parser","ParserHandle","NetworkStreamer","FileStreamer","StringStreamer","ReadableStreamStreamer","jQuery","each","prop","toUpperCase","toLowerCase","files","inputElem","instanceConfig","extend","before","action","reason","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getMatchingEdge","sourceData","_nodes","out","undirected","isPlainObject","isEmpty","privateProperty","configurable","writable","readOnlyProperty","descriptor","validateHints","hints","chain","iterables","current","Symbol","iterator","next","done","emptyIterator","GraphError","super","InvalidArgumentsGraphError","captureStackTrace","NotFoundGraphError","UsageGraphError","MixedNodeData","clear","DirectedNodeData","UndirectedNodeData","EdgeData","findRelevantNodeData","method","mode","nodeOrEdge","nameOrEdge","add1","add2","nodeData","edgeData","arg1","arg2","_edges","inDegree","outDegree","undirectedDegree","undirectedLoops","directedLoops","in","attach","outKey","inKey","attachMulti","adj","head","previous","detach","detachMulti","NODE_ATTRIBUTES_METHODS","element","attacher","Class","hasOwnProperty","updater","EDGE_ATTRIBUTES_METHODS","EDGES_ITERATION","direction","forEachSimple","breakable","object","callback","avoid","shouldBreak","forEachMulti","createIterator","sourceAttributes","targetAttributes","forEachForKeySimple","targetData","forEachForKeyMulti","createIteratorForKey","shouldFilter","mask","values","forEachEdgeForNode","found","forEachEdgeForPath","NEIGHBORS_ITERATION","CompositeSetWrapper","B","forEachInObjectOnce","visited","neighborData","forEachNeighbor","wrap","createDedupedObjectIterator","neighbor","forEachAdjacency","assymetric","disconnectedNodes","hasEdges","validateSerializedNode","validateSerializedEdge","INSTANCE_ID","floor","random","incrementalIdStartingFromRandomByte","TYPES","EMITTER_PROPS","DEFAULTS","allowSelfLoops","unsafeAddNode","NodeDataClass","addEdge","mustGenerateKey","eventData","_edgeKeyGenerator","isSelfLoop","_undirectedSelfLoopCount","_directedSelfLoopCount","_undirectedSize","_directedSize","mergeEdge","asUpdater","alreadyExistingEdgeData","info","oldAttributes","sourceWasAdded","targetWasAdded","dropEdgeFromData","delete","Graph","instancePrefix","edgeId","Map","availableEdgeKey","_options","_resetInstanceCounters","hasNode","hasDirectedEdge","hasUndirectedEdge","hasEdge","directedEdge","undirectedEdge","areDirectedNeighbors","areOutNeighbors","areInNeighbors","areUndirectedNeighbors","areNeighbors","areInboundNeighbors","areOutboundNeighbors","directedDegree","inboundDegree","degree","outboundDegree","inDegreeWithoutSelfLoops","outDegreeWithoutSelfLoops","directedDegreeWithoutSelfLoops","undirectedDegreeWithoutSelfLoops","inboundDegreeWithoutSelfLoops","loops","outboundDegreeWithoutSelfLoops","degreeWithoutSelfLoops","opposite","hasExtremity","isDirected","addNode","mergeNode","updateNode","dropEdge","dropDirectedEdge","dropUndirectedEdge","clearEdges","getAttribute","_attributes","getAttributes","hasAttribute","setAttribute","updateAttribute","removeAttribute","replaceAttributes","mergeAttributes","updateAttributes","updateEachEdgeAttributes","forEachAdjacencyEntry","forEachAdjacencyEntryWithOrphans","forEachAssymetricAdjacencyEntry","forEachAssymetricAdjacencyEntryWithOrphans","from","findNode","mapNodes","someNode","everyNode","filterNodes","reduceNodes","initialValue","accumulator","nodeEntries","serialized","serializeNode","serializeEdge","import","merge","_sa","_ta","mergeUndirectedEdgeWithKey","mergeDirectedEdgeWithKey","addDirectedEdgeWithKey","undirectedByDefault","mergeUndirectedEdge","mergeDirectedEdge","addUndirectedEdge","addDirectedEdge","nullCopy","emptyCopy","toJSON","export","inspect","multiIndex","tmp","label","desc","startsWith","dummy","for","verb","generateKey","attachNodeAttributesMethods","attachEdgeAttributesMethods","description","undirectedSize","directedSize","createEdgeArray","createEdgeArrayForNode","createEdgeArrayForPath","attachEdgeArrayCreator","forEachName","mapName","ea","filterName","reduceName","attachForEachEdge","findEdgeName","someName","everyName","attachFindEdge","originalName","createEdgeIterator","createEdgeIteratorForNode","createEdgeIteratorForPath","attachEdgeIteratorCreator","attachEdgeIterationMethods","neighbors","createNeighborArrayForNode","attachNeighborArrayCreator","attachForEachNeighbor","capitalizedSingular","findName","attachFindNeighbor","iteratorName","createNeighborIterator","attachNeighborIteratorCreator","attachNeighborIterationMethods","DirectedGraph","finalOptions","UndirectedGraph","MultiGraph","MultiDirectedGraph","MultiUndirectedGraph","attachStaticFromMethod","instance"],"sourceRoot":""}