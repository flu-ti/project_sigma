/*! For license information please see home.js.LICENSE.txt */
(()=>{var e={7:e=>{"use strict";var t,i="object"==typeof Reflect?Reflect:null,n=i&&"function"==typeof i.apply?i.apply:function(e,t,i){return Function.prototype.apply.call(e,t,i)};t=i&&"function"==typeof i.ownKeys?i.ownKeys:Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function(e){return Object.getOwnPropertyNames(e)};var r=Number.isNaN||function(e){return e!=e};function o(){o.init.call(this)}e.exports=o,e.exports.once=function(e,t){return new Promise((function(i,n){function r(i){e.removeListener(t,o),n(i)}function o(){"function"==typeof e.removeListener&&e.removeListener("error",r),i([].slice.call(arguments))}g(e,t,o,{once:!0}),"error"!==t&&function(e,t){"function"==typeof e.on&&g(e,"error",t,{once:!0})}(e,r)}))},o.EventEmitter=o,o.prototype._events=void 0,o.prototype._eventsCount=0,o.prototype._maxListeners=void 0;var s=10;function a(e){if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e)}function d(e){return void 0===e._maxListeners?o.defaultMaxListeners:e._maxListeners}function u(e,t,i,n){var r,o,s,u;if(a(i),void 0===(o=e._events)?(o=e._events=Object.create(null),e._eventsCount=0):(void 0!==o.newListener&&(e.emit("newListener",t,i.listener?i.listener:i),o=e._events),s=o[t]),void 0===s)s=o[t]=i,++e._eventsCount;else if("function"==typeof s?s=o[t]=n?[i,s]:[s,i]:n?s.unshift(i):s.push(i),(r=d(e))>0&&s.length>r&&!s.warned){s.warned=!0;var h=new Error("Possible EventEmitter memory leak detected. "+s.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");h.name="MaxListenersExceededWarning",h.emitter=e,h.type=t,h.count=s.length,u=h,console&&console.warn&&console.warn(u)}return e}function h(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function c(e,t,i){var n={fired:!1,wrapFn:void 0,target:e,type:t,listener:i},r=h.bind(n);return r.listener=i,n.wrapFn=r,r}function p(e,t,i){var n=e._events;if(void 0===n)return[];var r=n[t];return void 0===r?[]:"function"==typeof r?i?[r.listener||r]:[r]:i?function(e){for(var t=new Array(e.length),i=0;i<t.length;++i)t[i]=e[i].listener||e[i];return t}(r):l(r,r.length)}function f(e){var t=this._events;if(void 0!==t){var i=t[e];if("function"==typeof i)return 1;if(void 0!==i)return i.length}return 0}function l(e,t){for(var i=new Array(t),n=0;n<t;++n)i[n]=e[n];return i}function g(e,t,i,n){if("function"==typeof e.on)n.once?e.once(t,i):e.on(t,i);else{if("function"!=typeof e.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof e);e.addEventListener(t,(function r(o){n.once&&e.removeEventListener(t,r),i(o)}))}}Object.defineProperty(o,"defaultMaxListeners",{enumerable:!0,get:function(){return s},set:function(e){if("number"!=typeof e||e<0||r(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");s=e}}),o.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},o.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||r(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},o.prototype.getMaxListeners=function(){return d(this)},o.prototype.emit=function(e){for(var t=[],i=1;i<arguments.length;i++)t.push(arguments[i]);var r="error"===e,o=this._events;if(void 0!==o)r=r&&void 0===o.error;else if(!r)return!1;if(r){var s;if(t.length>0&&(s=t[0]),s instanceof Error)throw s;var a=new Error("Unhandled error."+(s?" ("+s.message+")":""));throw a.context=s,a}var d=o[e];if(void 0===d)return!1;if("function"==typeof d)n(d,this,t);else{var u=d.length,h=l(d,u);for(i=0;i<u;++i)n(h[i],this,t)}return!0},o.prototype.addListener=function(e,t){return u(this,e,t,!1)},o.prototype.on=o.prototype.addListener,o.prototype.prependListener=function(e,t){return u(this,e,t,!0)},o.prototype.once=function(e,t){return a(t),this.on(e,c(this,e,t)),this},o.prototype.prependOnceListener=function(e,t){return a(t),this.prependListener(e,c(this,e,t)),this},o.prototype.removeListener=function(e,t){var i,n,r,o,s;if(a(t),void 0===(n=this._events))return this;if(void 0===(i=n[e]))return this;if(i===t||i.listener===t)0==--this._eventsCount?this._events=Object.create(null):(delete n[e],n.removeListener&&this.emit("removeListener",e,i.listener||t));else if("function"!=typeof i){for(r=-1,o=i.length-1;o>=0;o--)if(i[o]===t||i[o].listener===t){s=i[o].listener,r=o;break}if(r<0)return this;0===r?i.shift():function(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}(i,r),1===i.length&&(n[e]=i[0]),void 0!==n.removeListener&&this.emit("removeListener",e,s||t)}return this},o.prototype.off=o.prototype.removeListener,o.prototype.removeAllListeners=function(e){var t,i,n;if(void 0===(i=this._events))return this;if(void 0===i.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==i[e]&&(0==--this._eventsCount?this._events=Object.create(null):delete i[e]),this;if(0===arguments.length){var r,o=Object.keys(i);for(n=0;n<o.length;++n)"removeListener"!==(r=o[n])&&this.removeAllListeners(r);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(t=i[e]))this.removeListener(e,t);else if(void 0!==t)for(n=t.length-1;n>=0;n--)this.removeListener(e,t[n]);return this},o.prototype.listeners=function(e){return p(this,e,!0)},o.prototype.rawListeners=function(e){return p(this,e,!1)},o.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):f.call(e,t)},o.prototype.listenerCount=f,o.prototype.eventNames=function(){return this._eventsCount>0?t(this._events):[]}},937:e=>{e.exports={linLogMode:!1,outboundAttractionDistribution:!1,adjustSizes:!1,edgeWeightInfluence:1,scalingRatio:1,strongGravityMode:!1,gravity:1,slowDown:1,barnesHutOptimize:!1,barnesHutTheta:.5}},782:(e,t)=>{t.assign=function(e){e=e||{};var t,i,n,r=Array.prototype.slice.call(arguments).slice(1);for(t=0,n=r.length;t<n;t++)if(r[t])for(i in r[t])e[i]=r[t][i];return e},t.validateSettings=function(e){return"linLogMode"in e&&"boolean"!=typeof e.linLogMode?{message:"the `linLogMode` setting should be a boolean."}:"outboundAttractionDistribution"in e&&"boolean"!=typeof e.outboundAttractionDistribution?{message:"the `outboundAttractionDistribution` setting should be a boolean."}:"adjustSizes"in e&&"boolean"!=typeof e.adjustSizes?{message:"the `adjustSizes` setting should be a boolean."}:"edgeWeightInfluence"in e&&"number"!=typeof e.edgeWeightInfluence?{message:"the `edgeWeightInfluence` setting should be a number."}:!("scalingRatio"in e)||"number"==typeof e.scalingRatio&&e.scalingRatio>=0?"strongGravityMode"in e&&"boolean"!=typeof e.strongGravityMode?{message:"the `strongGravityMode` setting should be a boolean."}:!("gravity"in e)||"number"==typeof e.gravity&&e.gravity>=0?"slowDown"in e&&!("number"==typeof e.slowDown||e.slowDown>=0)?{message:"the `slowDown` setting should be a number >= 0."}:"barnesHutOptimize"in e&&"boolean"!=typeof e.barnesHutOptimize?{message:"the `barnesHutOptimize` setting should be a boolean."}:!("barnesHutTheta"in e)||"number"==typeof e.barnesHutTheta&&e.barnesHutTheta>=0?null:{message:"the `barnesHutTheta` setting should be a number >= 0."}:{message:"the `gravity` setting should be a number >= 0."}:{message:"the `scalingRatio` setting should be a number >= 0."}},t.graphToByteArrays=function(e,t){var i,n=e.order,r=e.size,o={},s=new Float32Array(10*n),a=new Float32Array(3*r);return i=0,e.forEachNode((function(e,t){o[e]=i,s[i]=t.x,s[i+1]=t.y,s[i+2]=0,s[i+3]=0,s[i+4]=0,s[i+5]=0,s[i+6]=1,s[i+7]=1,s[i+8]=t.size||1,s[i+9]=t.fixed?1:0,i+=10})),i=0,e.forEachEdge((function(e,n,r,d,u,h,c){var p=o[r],f=o[d],l=t(e,n,r,d,u,h,c);s[p+6]+=l,s[f+6]+=l,a[i]=p,a[i+1]=f,a[i+2]=l,i+=3})),{nodes:s,edges:a}},t.assignLayoutChanges=function(e,t,i){var n=0;e.updateEachNodeAttributes((function(e,r){return r.x=t[n],r.y=t[n+1],n+=10,i?i(e,r):r}))},t.readGraphPositions=function(e,t){var i=0;e.forEachNode((function(e,n){t[i]=n.x,t[i+1]=n.y,i+=10}))},t.collectLayoutChanges=function(e,t,i){for(var n=e.nodes(),r={},o=0,s=0,a=t.length;o<a;o+=10){if(i){var d=Object.assign({},e.getNodeAttributes(n[s]));d.x=t[o],d.y=t[o+1],d=i(n[s],d),r[n[s]]={x:d.x,y:d.y}}else r[n[s]]={x:t[o],y:t[o+1]};s++}return r},t.createWorker=function(e){var t=window.URL||window.webkitURL,i=e.toString(),n=t.createObjectURL(new Blob(["("+i+").call(this);"],{type:"text/javascript"})),r=new Worker(n);return t.revokeObjectURL(n),r}},903:(e,t,i)=>{var n=i(736),r=i(153).Fd,o=i(561),s=i(782),a=i(937);function d(e,t,i){if(!n(t))throw new Error("graphology-layout-forceatlas2: the given graph is not a valid graphology instance.");"number"==typeof i&&(i={iterations:i});var d=i.iterations;if("number"!=typeof d)throw new Error("graphology-layout-forceatlas2: invalid number of iterations.");if(d<=0)throw new Error("graphology-layout-forceatlas2: you should provide a positive number of iterations.");var u=r("getEdgeWeight"in i?i.getEdgeWeight:"weight").fromEntry,h="function"==typeof i.outputReducer?i.outputReducer:null,c=s.assign({},a,i.settings),p=s.validateSettings(c);if(p)throw new Error("graphology-layout-forceatlas2: "+p.message);var f,l=s.graphToByteArrays(t,u);for(f=0;f<d;f++)o(c,l.nodes,l.edges);if(!e)return s.collectLayoutChanges(t,l.nodes);s.assignLayoutChanges(t,l.nodes,h)}var u=d.bind(null,!1);u.assign=d.bind(null,!0),u.inferSettings=function(e){var t="number"==typeof e?e:e.order;return{barnesHutOptimize:t>2e3,strongGravityMode:!0,gravity:.05,scalingRatio:10,slowDown:1+Math.log(t)}},e.exports=u},561:e=>{var t=10;e.exports=function(e,i,n){var r,o,s,a,d,u,h,c,p,f,l,g,y,m,w,b,v,_,k,E,$,x,G,A=i.length,S=n.length,L=e.adjustSizes,D=e.barnesHutTheta*e.barnesHutTheta,C=[];for(s=0;s<A;s+=t)i[s+4]=i[s+2],i[s+5]=i[s+3],i[s+2]=0,i[s+3]=0;if(e.outboundAttractionDistribution){for(l=0,s=0;s<A;s+=t)l+=i[s+6];l/=A/t}if(e.barnesHutOptimize){var O,M,R,U=1/0,N=-1/0,j=1/0,z=-1/0;for(s=0;s<A;s+=t)U=Math.min(U,i[s+0]),N=Math.max(N,i[s+0]),j=Math.min(j,i[s+1]),z=Math.max(z,i[s+1]);var T=N-U,I=z-j;for(T>I?z=(j-=(T-I)/2)+T:N=(U-=(I-T)/2)+I,C[0]=-1,C[1]=(U+N)/2,C[2]=(j+z)/2,C[3]=Math.max(N-U,z-j),C[4]=-1,C[5]=-1,C[6]=0,C[7]=0,C[8]=0,r=1,s=0;s<A;s+=t)for(o=0,R=3;;){if(!(C[o+5]>=0)){if(C[o+0]<0){C[o+0]=s;break}if(C[o+5]=9*r,c=C[o+3]/2,C[(p=C[o+5])+0]=-1,C[p+1]=C[o+1]-c,C[p+2]=C[o+2]-c,C[p+3]=c,C[p+4]=p+9,C[p+5]=-1,C[p+6]=0,C[p+7]=0,C[p+8]=0,C[(p+=9)+0]=-1,C[p+1]=C[o+1]-c,C[p+2]=C[o+2]+c,C[p+3]=c,C[p+4]=p+9,C[p+5]=-1,C[p+6]=0,C[p+7]=0,C[p+8]=0,C[(p+=9)+0]=-1,C[p+1]=C[o+1]+c,C[p+2]=C[o+2]-c,C[p+3]=c,C[p+4]=p+9,C[p+5]=-1,C[p+6]=0,C[p+7]=0,C[p+8]=0,C[(p+=9)+0]=-1,C[p+1]=C[o+1]+c,C[p+2]=C[o+2]+c,C[p+3]=c,C[p+4]=C[o+4],C[p+5]=-1,C[p+6]=0,C[p+7]=0,C[p+8]=0,r+=4,O=i[C[o+0]+0]<C[o+1]?i[C[o+0]+1]<C[o+2]?C[o+5]:C[o+5]+9:i[C[o+0]+1]<C[o+2]?C[o+5]+18:C[o+5]+27,C[o+6]=i[C[o+0]+6],C[o+7]=i[C[o+0]+0],C[o+8]=i[C[o+0]+1],C[O+0]=C[o+0],C[o+0]=-1,O===(M=i[s+0]<C[o+1]?i[s+1]<C[o+2]?C[o+5]:C[o+5]+9:i[s+1]<C[o+2]?C[o+5]+18:C[o+5]+27)){if(R--){o=O;continue}R=3;break}C[M+0]=s;break}O=i[s+0]<C[o+1]?i[s+1]<C[o+2]?C[o+5]:C[o+5]+9:i[s+1]<C[o+2]?C[o+5]+18:C[o+5]+27,C[o+7]=(C[o+7]*C[o+6]+i[s+0]*i[s+6])/(C[o+6]+i[s+6]),C[o+8]=(C[o+8]*C[o+6]+i[s+1]*i[s+6])/(C[o+6]+i[s+6]),C[o+6]+=i[s+6],o=O}}if(e.barnesHutOptimize){for(g=e.scalingRatio,s=0;s<A;s+=t)for(o=0;;)if(C[o+5]>=0){if(b=Math.pow(i[s+0]-C[o+7],2)+Math.pow(i[s+1]-C[o+8],2),4*(f=C[o+3])*f/b<D){if(y=i[s+0]-C[o+7],m=i[s+1]-C[o+8],!0===L?b>0?(v=g*i[s+6]*C[o+6]/b,i[s+2]+=y*v,i[s+3]+=m*v):b<0&&(v=-g*i[s+6]*C[o+6]/Math.sqrt(b),i[s+2]+=y*v,i[s+3]+=m*v):b>0&&(v=g*i[s+6]*C[o+6]/b,i[s+2]+=y*v,i[s+3]+=m*v),(o=C[o+4])<0)break;continue}o=C[o+5]}else if((u=C[o+0])>=0&&u!==s&&(b=(y=i[s+0]-i[u+0])*y+(m=i[s+1]-i[u+1])*m,!0===L?b>0?(v=g*i[s+6]*i[u+6]/b,i[s+2]+=y*v,i[s+3]+=m*v):b<0&&(v=-g*i[s+6]*i[u+6]/Math.sqrt(b),i[s+2]+=y*v,i[s+3]+=m*v):b>0&&(v=g*i[s+6]*i[u+6]/b,i[s+2]+=y*v,i[s+3]+=m*v)),(o=C[o+4])<0)break}else for(g=e.scalingRatio,a=0;a<A;a+=t)for(d=0;d<a;d+=t)y=i[a+0]-i[d+0],m=i[a+1]-i[d+1],!0===L?(b=Math.sqrt(y*y+m*m)-i[a+8]-i[d+8])>0?(v=g*i[a+6]*i[d+6]/b/b,i[a+2]+=y*v,i[a+3]+=m*v,i[d+2]-=y*v,i[d+3]-=m*v):b<0&&(v=100*g*i[a+6]*i[d+6],i[a+2]+=y*v,i[a+3]+=m*v,i[d+2]-=y*v,i[d+3]-=m*v):(b=Math.sqrt(y*y+m*m))>0&&(v=g*i[a+6]*i[d+6]/b/b,i[a+2]+=y*v,i[a+3]+=m*v,i[d+2]-=y*v,i[d+3]-=m*v);for(p=e.gravity/e.scalingRatio,g=e.scalingRatio,s=0;s<A;s+=t)v=0,y=i[s+0],m=i[s+1],b=Math.sqrt(Math.pow(y,2)+Math.pow(m,2)),e.strongGravityMode?b>0&&(v=g*i[s+6]*p):b>0&&(v=g*i[s+6]*p/b),i[s+2]-=y*v,i[s+3]-=m*v;for(g=1*(e.outboundAttractionDistribution?l:1),h=0;h<S;h+=3)a=n[h+0],d=n[h+1],c=n[h+2],w=Math.pow(c,e.edgeWeightInfluence),y=i[a+0]-i[d+0],m=i[a+1]-i[d+1],!0===L?(b=Math.sqrt(y*y+m*m)-i[a+8]-i[d+8],e.linLogMode?e.outboundAttractionDistribution?b>0&&(v=-g*w*Math.log(1+b)/b/i[a+6]):b>0&&(v=-g*w*Math.log(1+b)/b):e.outboundAttractionDistribution?b>0&&(v=-g*w/i[a+6]):b>0&&(v=-g*w)):(b=Math.sqrt(Math.pow(y,2)+Math.pow(m,2)),e.linLogMode?e.outboundAttractionDistribution?b>0&&(v=-g*w*Math.log(1+b)/b/i[a+6]):b>0&&(v=-g*w*Math.log(1+b)/b):e.outboundAttractionDistribution?(b=1,v=-g*w/i[a+6]):(b=1,v=-g*w)),b>0&&(i[a+2]+=y*v,i[a+3]+=m*v,i[d+2]-=y*v,i[d+3]-=m*v);if(!0===L)for(s=0;s<A;s+=t)1!==i[s+9]&&((_=Math.sqrt(Math.pow(i[s+2],2)+Math.pow(i[s+3],2)))>10&&(i[s+2]=10*i[s+2]/_,i[s+3]=10*i[s+3]/_),k=i[s+6]*Math.sqrt((i[s+4]-i[s+2])*(i[s+4]-i[s+2])+(i[s+5]-i[s+3])*(i[s+5]-i[s+3])),E=Math.sqrt((i[s+4]+i[s+2])*(i[s+4]+i[s+2])+(i[s+5]+i[s+3])*(i[s+5]+i[s+3]))/2,$=.1*Math.log(1+E)/(1+Math.sqrt(k)),x=i[s+0]+i[s+2]*($/e.slowDown),i[s+0]=x,G=i[s+1]+i[s+3]*($/e.slowDown),i[s+1]=G);else for(s=0;s<A;s+=t)1!==i[s+9]&&(k=i[s+6]*Math.sqrt((i[s+4]-i[s+2])*(i[s+4]-i[s+2])+(i[s+5]-i[s+3])*(i[s+5]-i[s+3])),E=Math.sqrt((i[s+4]+i[s+2])*(i[s+4]+i[s+2])+(i[s+5]+i[s+3])*(i[s+5]+i[s+3]))/2,$=i[s+7]*Math.log(1+E)/(1+Math.sqrt(k)),i[s+7]=Math.min(1,Math.sqrt($*(Math.pow(i[s+2],2)+Math.pow(i[s+3],2))/(1+Math.sqrt(k)))),x=i[s+0]+i[s+2]*($/e.slowDown),i[s+0]=x,G=i[s+1]+i[s+3]*($/e.slowDown),i[s+1]=G);return{}}},153:(e,t)=>{function i(e){return"number"!=typeof e||isNaN(e)?1:e}t.Fd=function(e){return function(e,t){var i={},n=function(e){return void 0===e?t:e};"function"==typeof t&&(n=t);var r=function(t){return n(t[e])},o=function(){return n(void 0)};return"string"==typeof e?(i.fromAttributes=r,i.fromGraph=function(e,t){return r(e.getEdgeAttributes(t))},i.fromEntry=function(e,t){return r(t)},i.fromPartialEntry=i.fromEntry,i.fromMinimalEntry=i.fromEntry):"function"==typeof e?(i.fromAttributes=function(){throw new Error("graphology-utils/getters/createEdgeValueGetter: irrelevant usage.")},i.fromGraph=function(t,i){var r=t.extremities(i);return n(e(i,t.getEdgeAttributes(i),r[0],r[1],t.getNodeAttributes(r[0]),t.getNodeAttributes(r[1]),t.isUndirected(i)))},i.fromEntry=function(t,i,r,o,s,a,d){return n(e(t,i,r,o,s,a,d))},i.fromPartialEntry=function(t,i,r,o){return n(e(t,i,r,o))},i.fromMinimalEntry=function(t,i){return n(e(t,i))}):(i.fromAttributes=o,i.fromGraph=o,i.fromEntry=o,i.fromMinimalEntry=o),i}(e,i)}},736:e=>{e.exports=function(e){return null!==e&&"object"==typeof e&&"function"==typeof e.addUndirectedEdgeWithKey&&"function"==typeof e.dropNode&&"boolean"==typeof e.multi}},809:function(e,t){var i,n;i=function e(){var t,i="undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==i?i:{},n=!i.document&&!!i.postMessage,r=i.IS_PAPA_WORKER||!1,o={},s=0,a={};function d(e){this._handle=null,this._finished=!1,this._completed=!1,this._halted=!1,this._input=null,this._baseIndex=0,this._partialLine="",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},function(e){var t=b(e);t.chunkSize=parseInt(t.chunkSize),e.step||e.chunk||(t.chunkSize=null),this._handle=new f(t),(this._handle.streamer=this)._config=t}.call(this,e),this.parseChunk=function(e,t){var n=parseInt(this._config.skipFirstNLines)||0;if(this.isFirstChunk&&0<n){let t=this._config.newline;t||(o=this._config.quoteChar||'"',t=this._handle.guessLineEndings(e,o)),e=[...e.split(t).slice(n)].join(t)}this.isFirstChunk&&_(this._config.beforeFirstChunk)&&void 0!==(o=this._config.beforeFirstChunk(e))&&(e=o),this.isFirstChunk=!1,this._halted=!1,n=this._partialLine+e;var o=(this._partialLine="",this._handle.parse(n,this._baseIndex,!this._finished));if(!this._handle.paused()&&!this._handle.aborted()){if(e=o.meta.cursor,this._finished||(this._partialLine=n.substring(e-this._baseIndex),this._baseIndex=e),o&&o.data&&(this._rowCount+=o.data.length),n=this._finished||this._config.preview&&this._rowCount>=this._config.preview,r)i.postMessage({results:o,workerId:a.WORKER_ID,finished:n});else if(_(this._config.chunk)&&!t){if(this._config.chunk(o,this._handle),this._handle.paused()||this._handle.aborted())return void(this._halted=!0);this._completeResults=o=void 0}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(o.data),this._completeResults.errors=this._completeResults.errors.concat(o.errors),this._completeResults.meta=o.meta),this._completed||!n||!_(this._config.complete)||o&&o.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),n||o&&o.meta.paused||this._nextChunk(),o}this._halted=!0},this._sendError=function(e){_(this._config.error)?this._config.error(e):r&&this._config.error&&i.postMessage({workerId:a.WORKER_ID,error:e,finished:!1})}}function u(e){var t;(e=e||{}).chunkSize||(e.chunkSize=a.RemoteChunkSize),d.call(this,e),this._nextChunk=n?function(){this._readChunk(),this._chunkLoaded()}:function(){this._readChunk()},this.stream=function(e){this._input=e,this._nextChunk()},this._readChunk=function(){if(this._finished)this._chunkLoaded();else{if(t=new XMLHttpRequest,this._config.withCredentials&&(t.withCredentials=this._config.withCredentials),n||(t.onload=v(this._chunkLoaded,this),t.onerror=v(this._chunkError,this)),t.open(this._config.downloadRequestBody?"POST":"GET",this._input,!n),this._config.downloadRequestHeaders){var e,i=this._config.downloadRequestHeaders;for(e in i)t.setRequestHeader(e,i[e])}var r;this._config.chunkSize&&(r=this._start+this._config.chunkSize-1,t.setRequestHeader("Range","bytes="+this._start+"-"+r));try{t.send(this._config.downloadRequestBody)}catch(e){this._chunkError(e.message)}n&&0===t.status&&this._chunkError()}},this._chunkLoaded=function(){4===t.readyState&&(t.status<200||400<=t.status?this._chunkError():(this._start+=this._config.chunkSize||t.responseText.length,this._finished=!this._config.chunkSize||this._start>=(e=>null!==(e=e.getResponseHeader("Content-Range"))?parseInt(e.substring(e.lastIndexOf("/")+1)):-1)(t),this.parseChunk(t.responseText)))},this._chunkError=function(e){e=t.statusText||e,this._sendError(new Error(e))}}function h(e){(e=e||{}).chunkSize||(e.chunkSize=a.LocalChunkSize),d.call(this,e);var t,i,n="undefined"!=typeof FileReader;this.stream=function(e){this._input=e,i=e.slice||e.webkitSlice||e.mozSlice,n?((t=new FileReader).onload=v(this._chunkLoaded,this),t.onerror=v(this._chunkError,this)):t=new FileReaderSync,this._nextChunk()},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk()},this._readChunk=function(){var e=this._input,r=(this._config.chunkSize&&(r=Math.min(this._start+this._config.chunkSize,this._input.size),e=i.call(e,this._start,r)),t.readAsText(e,this._config.encoding));n||this._chunkLoaded({target:{result:r}})},this._chunkLoaded=function(e){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(e.target.result)},this._chunkError=function(){this._sendError(t.error)}}function c(e){var t;d.call(this,e=e||{}),this.stream=function(e){return t=e,this._nextChunk()},this._nextChunk=function(){var e,i;if(!this._finished)return e=this._config.chunkSize,t=e?(i=t.substring(0,e),t.substring(e)):(i=t,""),this._finished=!t,this.parseChunk(i)}}function p(e){d.call(this,e=e||{});var t=[],i=!0,n=!1;this.pause=function(){d.prototype.pause.apply(this,arguments),this._input.pause()},this.resume=function(){d.prototype.resume.apply(this,arguments),this._input.resume()},this.stream=function(e){this._input=e,this._input.on("data",this._streamData),this._input.on("end",this._streamEnd),this._input.on("error",this._streamError)},this._checkIsFinished=function(){n&&1===t.length&&(this._finished=!0)},this._nextChunk=function(){this._checkIsFinished(),t.length?this.parseChunk(t.shift()):i=!0},this._streamData=v((function(e){try{t.push("string"==typeof e?e:e.toString(this._config.encoding)),i&&(i=!1,this._checkIsFinished(),this.parseChunk(t.shift()))}catch(e){this._streamError(e)}}),this),this._streamError=v((function(e){this._streamCleanUp(),this._sendError(e)}),this),this._streamEnd=v((function(){this._streamCleanUp(),n=!0,this._streamData("")}),this),this._streamCleanUp=v((function(){this._input.removeListener("data",this._streamData),this._input.removeListener("end",this._streamEnd),this._input.removeListener("error",this._streamError)}),this)}function f(e){var t,i,n,r,o=Math.pow(2,53),s=-o,d=/^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/,u=/^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/,h=this,c=0,p=0,f=!1,y=!1,m=[],w={data:[],errors:[],meta:{}};function v(t){return"greedy"===e.skipEmptyLines?""===t.join("").trim():1===t.length&&0===t[0].length}function k(){if(w&&n&&($("Delimiter","UndetectableDelimiter","Unable to auto-detect delimiting character; defaulted to '"+a.DefaultDelimiter+"'"),n=!1),e.skipEmptyLines&&(w.data=w.data.filter((function(e){return!v(e)}))),E()){if(w)if(Array.isArray(w.data[0])){for(var t=0;E()&&t<w.data.length;t++)w.data[t].forEach(i);w.data.splice(0,1)}else w.data.forEach(i);function i(t,i){_(e.transformHeader)&&(t=e.transformHeader(t,i)),m.push(t)}}function r(t,i){for(var n=e.header?{}:[],r=0;r<t.length;r++){var a=r,h=t[r];h=((t,i)=>(t=>(e.dynamicTypingFunction&&void 0===e.dynamicTyping[t]&&(e.dynamicTyping[t]=e.dynamicTypingFunction(t)),!0===(e.dynamicTyping[t]||e.dynamicTyping)))(t)?"true"===i||"TRUE"===i||"false"!==i&&"FALSE"!==i&&((e=>{if(d.test(e)&&(e=parseFloat(e),s<e&&e<o))return 1})(i)?parseFloat(i):u.test(i)?new Date(i):""===i?null:i):i)(a=e.header?r>=m.length?"__parsed_extra":m[r]:a,h=e.transform?e.transform(h,a):h),"__parsed_extra"===a?(n[a]=n[a]||[],n[a].push(h)):n[a]=h}return e.header&&(r>m.length?$("FieldMismatch","TooManyFields","Too many fields: expected "+m.length+" fields but parsed "+r,p+i):r<m.length&&$("FieldMismatch","TooFewFields","Too few fields: expected "+m.length+" fields but parsed "+r,p+i)),n}var h;w&&(e.header||e.dynamicTyping||e.transform)&&(h=1,!w.data.length||Array.isArray(w.data[0])?(w.data=w.data.map(r),h=w.data.length):w.data=r(w.data,0),e.header&&w.meta&&(w.meta.fields=m),p+=h)}function E(){return e.header&&0===m.length}function $(e,t,i,n){e={type:e,code:t,message:i},void 0!==n&&(e.row=n),w.errors.push(e)}_(e.step)&&(r=e.step,e.step=function(t){w=t,E()?k():(k(),0!==w.data.length&&(c+=t.data.length,e.preview&&c>e.preview?i.abort():(w.data=w.data[0],r(w,h))))}),this.parse=function(r,o,s){var d=e.quoteChar||'"';return e.newline||(e.newline=this.guessLineEndings(r,d)),n=!1,e.delimiter?_(e.delimiter)&&(e.delimiter=e.delimiter(r),w.meta.delimiter=e.delimiter):((d=((t,i,n,r,o)=>{var s,d,u,h;o=o||[",","\t","|",";",a.RECORD_SEP,a.UNIT_SEP];for(var c=0;c<o.length;c++){for(var p,f=o[c],l=0,y=0,m=0,w=(u=void 0,new g({comments:r,delimiter:f,newline:i,preview:10}).parse(t)),b=0;b<w.data.length;b++)n&&v(w.data[b])?m++:(y+=p=w.data[b].length,void 0===u?u=p:0<p&&(l+=Math.abs(p-u),u=p));0<w.data.length&&(y/=w.data.length-m),(void 0===d||l<=d)&&(void 0===h||h<y)&&1.99<y&&(d=l,s=f,h=y)}return{successful:!!(e.delimiter=s),bestDelimiter:s}})(r,e.newline,e.skipEmptyLines,e.comments,e.delimitersToGuess)).successful?e.delimiter=d.bestDelimiter:(n=!0,e.delimiter=a.DefaultDelimiter),w.meta.delimiter=e.delimiter),d=b(e),e.preview&&e.header&&d.preview++,t=r,i=new g(d),w=i.parse(t,o,s),k(),f?{meta:{paused:!0}}:w||{meta:{paused:!1}}},this.paused=function(){return f},this.pause=function(){f=!0,i.abort(),t=_(e.chunk)?"":t.substring(i.getCharIndex())},this.resume=function(){h.streamer._halted?(f=!1,h.streamer.parseChunk(t,!0)):setTimeout(h.resume,3)},this.aborted=function(){return y},this.abort=function(){y=!0,i.abort(),w.meta.aborted=!0,_(e.complete)&&e.complete(w),t=""},this.guessLineEndings=function(e,t){e=e.substring(0,1048576),t=new RegExp(l(t)+"([^]*?)"+l(t),"gm");var i=(e=e.replace(t,"")).split("\r");if(e=1<(t=e.split("\n")).length&&t[0].length<i[0].length,1===i.length||e)return"\n";for(var n=0,r=0;r<i.length;r++)"\n"===i[r][0]&&n++;return n>=i.length/2?"\r\n":"\r"}}function l(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function g(e){var t=(e=e||{}).delimiter,i=e.newline,n=e.comments,r=e.step,o=e.preview,s=e.fastMode,d=null,u=null==e.quoteChar?'"':e.quoteChar,h=u;if(void 0!==e.escapeChar&&(h=e.escapeChar),("string"!=typeof t||-1<a.BAD_DELIMITERS.indexOf(t))&&(t=","),n===t)throw new Error("Comment character same as delimiter");!0===n?n="#":("string"!=typeof n||-1<a.BAD_DELIMITERS.indexOf(n))&&(n=!1),"\n"!==i&&"\r"!==i&&"\r\n"!==i&&(i="\n");var c=0,p=!1;this.parse=function(a,f,g){if("string"!=typeof a)throw new Error("Input must be a string");var y=a.length,m=t.length,w=i.length,b=n.length,v=_(r),k=[],E=[],$=[],x=c=0;if(!a)return j();if(s||!1!==s&&-1===a.indexOf(u)){for(var G=a.split(i),A=0;A<G.length;A++){if($=G[A],c+=$.length,A!==G.length-1)c+=i.length;else if(g)return j();if(!n||$.substring(0,b)!==n){if(v){if(k=[],M($.split(t)),z(),p)return j()}else M($.split(t));if(o&&o<=A)return k=k.slice(0,o),j(!0)}}return j()}for(var S=a.indexOf(t,c),L=a.indexOf(i,c),D=new RegExp(l(h)+l(u),"g"),C=a.indexOf(u,c);;)if(a[c]===u)for(C=c,c++;;){if(-1===(C=a.indexOf(u,C+1)))return g||E.push({type:"Quotes",code:"MissingQuotes",message:"Quoted field unterminated",row:k.length,index:c}),U();if(C===y-1)return U(a.substring(c,C).replace(D,u));if(u===h&&a[C+1]===h)C++;else if(u===h||0===C||a[C-1]!==h){-1!==S&&S<C+1&&(S=a.indexOf(t,C+1));var O=R(-1===(L=-1!==L&&L<C+1?a.indexOf(i,C+1):L)?S:Math.min(S,L));if(a.substr(C+1+O,m)===t){$.push(a.substring(c,C).replace(D,u)),a[c=C+1+O+m]!==u&&(C=a.indexOf(u,c)),S=a.indexOf(t,c),L=a.indexOf(i,c);break}if(O=R(L),a.substring(C+1+O,C+1+O+w)===i){if($.push(a.substring(c,C).replace(D,u)),N(C+1+O+w),S=a.indexOf(t,c),C=a.indexOf(u,c),v&&(z(),p))return j();if(o&&k.length>=o)return j(!0);break}E.push({type:"Quotes",code:"InvalidQuotes",message:"Trailing quote on quoted field is malformed",row:k.length,index:c}),C++}}else if(n&&0===$.length&&a.substring(c,c+b)===n){if(-1===L)return j();c=L+w,L=a.indexOf(i,c),S=a.indexOf(t,c)}else if(-1!==S&&(S<L||-1===L))$.push(a.substring(c,S)),c=S+m,S=a.indexOf(t,c);else{if(-1===L)break;if($.push(a.substring(c,L)),N(L+w),v&&(z(),p))return j();if(o&&k.length>=o)return j(!0)}return U();function M(e){k.push(e),x=c}function R(e){return-1!==e&&(e=a.substring(C+1,e))&&""===e.trim()?e.length:0}function U(e){return g||(void 0===e&&(e=a.substring(c)),$.push(e),c=y,M($),v&&z()),j()}function N(e){c=e,M($),$=[],L=a.indexOf(i,c)}function j(n){if(e.header&&!f&&k.length){var r=k[0],o={},s=new Set(r);let t=!1;for(let i=0;i<r.length;i++){let n=r[i];if(o[n=_(e.transformHeader)?e.transformHeader(n,i):n]){let e,a=o[n];for(;e=n+"_"+a,a++,s.has(e););s.add(e),r[i]=e,o[n]++,t=!0,(d=null===d?{}:d)[e]=n}else o[n]=1,r[i]=n;s.add(n)}t&&console.warn("Duplicate headers found and renamed.")}return{data:k,errors:E,meta:{delimiter:t,linebreak:i,aborted:p,truncated:!!n,cursor:x+(f||0),renamedHeaders:d}}}function z(){r(j()),k=[],E=[]}},this.abort=function(){p=!0},this.getCharIndex=function(){return c}}function y(e){var t=e.data,i=o[t.workerId],n=!1;if(t.error)i.userError(t.error,t.file);else if(t.results&&t.results.data){var r={abort:function(){n=!0,m(t.workerId,{data:[],errors:[],meta:{aborted:!0}})},pause:w,resume:w};if(_(i.userStep)){for(var s=0;s<t.results.data.length&&(i.userStep({data:t.results.data[s],errors:t.results.errors,meta:t.results.meta},r),!n);s++);delete t.results}else _(i.userChunk)&&(i.userChunk(t.results,r,t.file),delete t.results)}t.finished&&!n&&m(t.workerId,t.results)}function m(e,t){var i=o[e];_(i.userComplete)&&i.userComplete(t),i.terminate(),delete o[e]}function w(){throw new Error("Not implemented.")}function b(e){if("object"!=typeof e||null===e)return e;var t,i=Array.isArray(e)?[]:{};for(t in e)i[t]=b(e[t]);return i}function v(e,t){return function(){e.apply(t,arguments)}}function _(e){return"function"==typeof e}return a.parse=function(t,n){var r=(n=n||{}).dynamicTyping||!1;if(_(r)&&(n.dynamicTypingFunction=r,r={}),n.dynamicTyping=r,n.transform=!!_(n.transform)&&n.transform,!n.worker||!a.WORKERS_SUPPORTED)return r=null,a.NODE_STREAM_INPUT,"string"==typeof t?(t=(e=>65279!==e.charCodeAt(0)?e:e.slice(1))(t),r=new(n.download?u:c)(n)):!0===t.readable&&_(t.read)&&_(t.on)?r=new p(n):(i.File&&t instanceof File||t instanceof Object)&&(r=new h(n)),r.stream(t);(r=(()=>{var t;return!!a.WORKERS_SUPPORTED&&(t=(()=>{var t=i.URL||i.webkitURL||null,n=e.toString();return a.BLOB_URL||(a.BLOB_URL=t.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ","(",n,")();"],{type:"text/javascript"})))})(),(t=new i.Worker(t)).onmessage=y,t.id=s++,o[t.id]=t)})()).userStep=n.step,r.userChunk=n.chunk,r.userComplete=n.complete,r.userError=n.error,n.step=_(n.step),n.chunk=_(n.chunk),n.complete=_(n.complete),n.error=_(n.error),delete n.worker,r.postMessage({input:t,config:n,workerId:r.id})},a.unparse=function(e,t){var i=!1,n=!0,r=",",o="\r\n",s='"',d=s+s,u=!1,h=null,c=!1,p=((()=>{if("object"==typeof t){if("string"!=typeof t.delimiter||a.BAD_DELIMITERS.filter((function(e){return-1!==t.delimiter.indexOf(e)})).length||(r=t.delimiter),"boolean"!=typeof t.quotes&&"function"!=typeof t.quotes&&!Array.isArray(t.quotes)||(i=t.quotes),"boolean"!=typeof t.skipEmptyLines&&"string"!=typeof t.skipEmptyLines||(u=t.skipEmptyLines),"string"==typeof t.newline&&(o=t.newline),"string"==typeof t.quoteChar&&(s=t.quoteChar),"boolean"==typeof t.header&&(n=t.header),Array.isArray(t.columns)){if(0===t.columns.length)throw new Error("Option columns is empty");h=t.columns}void 0!==t.escapeChar&&(d=t.escapeChar+s),t.escapeFormulae instanceof RegExp?c=t.escapeFormulae:"boolean"==typeof t.escapeFormulae&&t.escapeFormulae&&(c=/^[=+\-@\t\r].*$/)}})(),new RegExp(l(s),"g"));if("string"==typeof e&&(e=JSON.parse(e)),Array.isArray(e)){if(!e.length||Array.isArray(e[0]))return f(null,e,u);if("object"==typeof e[0])return f(h||Object.keys(e[0]),e,u)}else if("object"==typeof e)return"string"==typeof e.data&&(e.data=JSON.parse(e.data)),Array.isArray(e.data)&&(e.fields||(e.fields=e.meta&&e.meta.fields||h),e.fields||(e.fields=Array.isArray(e.data[0])?e.fields:"object"==typeof e.data[0]?Object.keys(e.data[0]):[]),Array.isArray(e.data[0])||"object"==typeof e.data[0]||(e.data=[e.data])),f(e.fields||[],e.data||[],u);throw new Error("Unable to serialize unrecognized input");function f(e,t,i){var s="",a=("string"==typeof e&&(e=JSON.parse(e)),"string"==typeof t&&(t=JSON.parse(t)),Array.isArray(e)&&0<e.length),d=!Array.isArray(t[0]);if(a&&n){for(var u=0;u<e.length;u++)0<u&&(s+=r),s+=g(e[u],u);0<t.length&&(s+=o)}for(var h=0;h<t.length;h++){var c=(a?e:t[h]).length,p=!1,f=a?0===Object.keys(t[h]).length:0===t[h].length;if(i&&!a&&(p="greedy"===i?""===t[h].join("").trim():1===t[h].length&&0===t[h][0].length),"greedy"===i&&a){for(var l=[],y=0;y<c;y++){var m=d?e[y]:y;l.push(t[h][m])}p=""===l.join("").trim()}if(!p){for(var w=0;w<c;w++){0<w&&!f&&(s+=r);var b=a&&d?e[w]:w;s+=g(t[h][b],w)}h<t.length-1&&(!i||0<c&&!f)&&(s+=o)}}return s}function g(e,t){var n,o;return null==e?"":e.constructor===Date?JSON.stringify(e).slice(1,25):(o=!1,c&&"string"==typeof e&&c.test(e)&&(e="'"+e,o=!0),n=e.toString().replace(p,d),(o=o||!0===i||"function"==typeof i&&i(e,t)||Array.isArray(i)&&i[t]||((e,t)=>{for(var i=0;i<t.length;i++)if(-1<e.indexOf(t[i]))return!0;return!1})(n,a.BAD_DELIMITERS)||-1<n.indexOf(r)||" "===n.charAt(0)||" "===n.charAt(n.length-1))?s+n+s:n)}},a.RECORD_SEP=String.fromCharCode(30),a.UNIT_SEP=String.fromCharCode(31),a.BYTE_ORDER_MARK="\ufeff",a.BAD_DELIMITERS=["\r","\n",'"',a.BYTE_ORDER_MARK],a.WORKERS_SUPPORTED=!n&&!!i.Worker,a.NODE_STREAM_INPUT=1,a.LocalChunkSize=10485760,a.RemoteChunkSize=5242880,a.DefaultDelimiter=",",a.Parser=g,a.ParserHandle=f,a.NetworkStreamer=u,a.FileStreamer=h,a.StringStreamer=c,a.ReadableStreamStreamer=p,i.jQuery&&((t=i.jQuery).fn.parse=function(e){var n=e.config||{},r=[];return this.each((function(e){if("INPUT"!==t(this).prop("tagName").toUpperCase()||"file"!==t(this).attr("type").toLowerCase()||!i.FileReader||!this.files||0===this.files.length)return!0;for(var o=0;o<this.files.length;o++)r.push({file:this.files[o],inputElem:this,instanceConfig:t.extend({},n)})})),o(),this;function o(){if(0===r.length)_(e.complete)&&e.complete();else{var i,n,o,d=r[0];if(_(e.before)){var u=e.before(d.file,d.inputElem);if("object"==typeof u){if("abort"===u.action)return i=d.file,n=d.inputElem,o=u.reason,void(_(e.error)&&e.error({name:"AbortError"},i,n,o));if("skip"===u.action)return void s();"object"==typeof u.config&&(d.instanceConfig=t.extend(d.instanceConfig,u.config))}else if("skip"===u)return void s()}var h=d.instanceConfig.complete;d.instanceConfig.complete=function(e){_(h)&&h(e,d.file,d.inputElem),s()},a.parse(d.file,d.instanceConfig)}}function s(){r.splice(0,1),o()}}),r&&(i.onmessage=function(e){e=e.data,void 0===a.WORKER_ID&&e&&(a.WORKER_ID=e.workerId),"string"==typeof e.input?i.postMessage({workerId:a.WORKER_ID,results:a.parse(e.input,e.config),finished:!0}):(i.File&&e.input instanceof File||e.input instanceof Object)&&(e=a.parse(e.input,e.config))&&i.postMessage({workerId:a.WORKER_ID,results:e,finished:!0})}),(u.prototype=Object.create(d.prototype)).constructor=u,(h.prototype=Object.create(d.prototype)).constructor=h,(c.prototype=Object.create(c.prototype)).constructor=c,(p.prototype=Object.create(d.prototype)).constructor=p,a},void 0===(n=i.apply(t,[]))||(e.exports=n)}},t={};function i(n){var r=t[n];if(void 0!==r)return r.exports;var o=t[n]={exports:{}};return e[n].call(o.exports,o,o.exports,i),o.exports}(()=>{"use strict";var e=i(7);let t=function(){const e=arguments[0];for(let t=1,i=arguments.length;t<i;t++)if(arguments[t])for(const i in arguments[t])e[i]=arguments[t][i];return e};function n(e,t,i,n){const r=e._nodes.get(t);let o=null;return r?(o="mixed"===n?r.out&&r.out[i]||r.undirected&&r.undirected[i]:"directed"===n?r.out&&r.out[i]:r.undirected&&r.undirected[i],o):o}function r(e){return"object"==typeof e&&null!==e}function o(e){let t;for(t in e)return!1;return!0}function s(e,t,i){Object.defineProperty(e,t,{enumerable:!1,configurable:!1,writable:!0,value:i})}function a(e,t,i){const n={enumerable:!0,configurable:!0};"function"==typeof i?n.get=i:(n.value=i,n.writable=!1),Object.defineProperty(e,t,n)}function d(e){return!(!r(e)||e.attributes&&!Array.isArray(e.attributes))}function u(){const e=arguments;let t=null,i=-1;return{[Symbol.iterator](){return this},next(){let n=null;for(;;){if(null===t){if(i++,i>=e.length)return{done:!0};t=e[i][Symbol.iterator]()}if(n=t.next(),!n.done)break;t=null}return n}}}function h(){return{[Symbol.iterator](){return this},next:()=>({done:!0})}}"function"==typeof Object.assign&&(t=Object.assign);class c extends Error{constructor(e){super(),this.name="GraphError",this.message=e}}class p extends c{constructor(e){super(e),this.name="InvalidArgumentsGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,p.prototype.constructor)}}class f extends c{constructor(e){super(e),this.name="NotFoundGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,f.prototype.constructor)}}class l extends c{constructor(e){super(e),this.name="UsageGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,l.prototype.constructor)}}function g(e,t){this.key=e,this.attributes=t,this.clear()}function y(e,t){this.key=e,this.attributes=t,this.clear()}function m(e,t){this.key=e,this.attributes=t,this.clear()}function w(e,t,i,n,r){this.key=t,this.attributes=r,this.undirected=e,this.source=i,this.target=n}function b(e,t,i,n,r,o,s){let a,d,u,h;if(n=""+n,0===i){if(a=e._nodes.get(n),!a)throw new f(`Graph.${t}: could not find the "${n}" node in the graph.`);u=r,h=o}else if(3===i){if(r=""+r,d=e._edges.get(r),!d)throw new f(`Graph.${t}: could not find the "${r}" edge in the graph.`);const i=d.source.key,c=d.target.key;if(n===i)a=d.target;else{if(n!==c)throw new f(`Graph.${t}: the "${n}" node is not attached to the "${r}" edge (${i}, ${c}).`);a=d.source}u=o,h=s}else{if(d=e._edges.get(n),!d)throw new f(`Graph.${t}: could not find the "${n}" edge in the graph.`);a=1===i?d.source:d.target,u=r,h=o}return[a,u,h]}g.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}},y.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}},m.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}},w.prototype.attach=function(){let e="out",t="in";this.undirected&&(e=t="undirected");const i=this.source.key,n=this.target.key;this.source[e][n]=this,this.undirected&&i===n||(this.target[t][i]=this)},w.prototype.attachMulti=function(){let e="out",t="in";const i=this.source.key,n=this.target.key;this.undirected&&(e=t="undirected");const r=this.source[e],o=r[n];if(void 0===o)return r[n]=this,void(this.undirected&&i===n||(this.target[t][i]=this));o.previous=this,this.next=o,r[n]=this,this.target[t][i]=this},w.prototype.detach=function(){const e=this.source.key,t=this.target.key;let i="out",n="in";this.undirected&&(i=n="undirected"),delete this.source[i][t],delete this.target[n][e]},w.prototype.detachMulti=function(){const e=this.source.key,t=this.target.key;let i="out",n="in";this.undirected&&(i=n="undirected"),void 0===this.previous?void 0===this.next?(delete this.source[i][t],delete this.target[n][e]):(this.next.previous=void 0,this.source[i][t]=this.next,this.target[n][e]=this.next):(this.previous.next=this.next,void 0!==this.next&&(this.next.previous=this.previous))};const v=[{name:e=>`get${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,n,r){const[o,s]=b(this,t,i,e,n,r);return o.attributes[s]}}},{name:e=>`get${e}Attributes`,attacher:function(e,t,i){e.prototype[t]=function(e,n){const[r]=b(this,t,i,e,n);return r.attributes}}},{name:e=>`has${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,n,r){const[o,s]=b(this,t,i,e,n,r);return o.attributes.hasOwnProperty(s)}}},{name:e=>`set${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,n,r,o){const[s,a,d]=b(this,t,i,e,n,r,o);return s.attributes[a]=d,this.emit("nodeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:a}),this}}},{name:e=>`update${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,n,r,o){const[s,a,d]=b(this,t,i,e,n,r,o);if("function"!=typeof d)throw new p(`Graph.${t}: updater should be a function.`);const u=s.attributes,h=d(u[a]);return u[a]=h,this.emit("nodeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:a}),this}}},{name:e=>`remove${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,n,r){const[o,s]=b(this,t,i,e,n,r);return delete o.attributes[s],this.emit("nodeAttributesUpdated",{key:o.key,type:"remove",attributes:o.attributes,name:s}),this}}},{name:e=>`replace${e}Attributes`,attacher:function(e,t,i){e.prototype[t]=function(e,n,o){const[s,a]=b(this,t,i,e,n,o);if(!r(a))throw new p(`Graph.${t}: provided attributes are not a plain object.`);return s.attributes=a,this.emit("nodeAttributesUpdated",{key:s.key,type:"replace",attributes:s.attributes}),this}}},{name:e=>`merge${e}Attributes`,attacher:function(e,i,n){e.prototype[i]=function(e,o,s){const[a,d]=b(this,i,n,e,o,s);if(!r(d))throw new p(`Graph.${i}: provided attributes are not a plain object.`);return t(a.attributes,d),this.emit("nodeAttributesUpdated",{key:a.key,type:"merge",attributes:a.attributes,data:d}),this}}},{name:e=>`update${e}Attributes`,attacher:function(e,t,i){e.prototype[t]=function(e,n,r){const[o,s]=b(this,t,i,e,n,r);if("function"!=typeof s)throw new p(`Graph.${t}: provided updater is not a function.`);return o.attributes=s(o.attributes),this.emit("nodeAttributesUpdated",{key:o.key,type:"update",attributes:o.attributes}),this}}}],_=[{name:e=>`get${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,r){let o;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new l(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new l(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+e,a=""+r;if(r=arguments[2],o=n(this,s,a,i),!o)throw new f(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if("mixed"!==i)throw new l(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,o=this._edges.get(e),!o)throw new f(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return o.attributes[r]}}},{name:e=>`get${e}Attributes`,attacher:function(e,t,i){e.prototype[t]=function(e){let r;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new l(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>1){if(this.multi)throw new l(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+e,s=""+arguments[1];if(r=n(this,o,s,i),!r)throw new f(`Graph.${t}: could not find an edge for the given path ("${o}" - "${s}").`)}else{if("mixed"!==i)throw new l(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,r=this._edges.get(e),!r)throw new f(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return r.attributes}}},{name:e=>`has${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,r){let o;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new l(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new l(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+e,a=""+r;if(r=arguments[2],o=n(this,s,a,i),!o)throw new f(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if("mixed"!==i)throw new l(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,o=this._edges.get(e),!o)throw new f(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return o.attributes.hasOwnProperty(r)}}},{name:e=>`set${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,r,o){let s;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new l(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new l(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const a=""+e,d=""+r;if(r=arguments[2],o=arguments[3],s=n(this,a,d,i),!s)throw new f(`Graph.${t}: could not find an edge for the given path ("${a}" - "${d}").`)}else{if("mixed"!==i)throw new l(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,s=this._edges.get(e),!s)throw new f(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return s.attributes[r]=o,this.emit("edgeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:r}),this}}},{name:e=>`update${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,r,o){let s;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new l(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new l(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const a=""+e,d=""+r;if(r=arguments[2],o=arguments[3],s=n(this,a,d,i),!s)throw new f(`Graph.${t}: could not find an edge for the given path ("${a}" - "${d}").`)}else{if("mixed"!==i)throw new l(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,s=this._edges.get(e),!s)throw new f(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if("function"!=typeof o)throw new p(`Graph.${t}: updater should be a function.`);return s.attributes[r]=o(s.attributes[r]),this.emit("edgeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:r}),this}}},{name:e=>`remove${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,r){let o;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new l(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new l(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+e,a=""+r;if(r=arguments[2],o=n(this,s,a,i),!o)throw new f(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if("mixed"!==i)throw new l(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,o=this._edges.get(e),!o)throw new f(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return delete o.attributes[r],this.emit("edgeAttributesUpdated",{key:o.key,type:"remove",attributes:o.attributes,name:r}),this}}},{name:e=>`replace${e}Attributes`,attacher:function(e,t,i){e.prototype[t]=function(e,o){let s;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new l(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new l(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const r=""+e,a=""+o;if(o=arguments[2],s=n(this,r,a,i),!s)throw new f(`Graph.${t}: could not find an edge for the given path ("${r}" - "${a}").`)}else{if("mixed"!==i)throw new l(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,s=this._edges.get(e),!s)throw new f(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if(!r(o))throw new p(`Graph.${t}: provided attributes are not a plain object.`);return s.attributes=o,this.emit("edgeAttributesUpdated",{key:s.key,type:"replace",attributes:s.attributes}),this}}},{name:e=>`merge${e}Attributes`,attacher:function(e,i,o){e.prototype[i]=function(e,s){let a;if("mixed"!==this.type&&"mixed"!==o&&o!==this.type)throw new l(`Graph.${i}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new l(`Graph.${i}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const t=""+e,r=""+s;if(s=arguments[2],a=n(this,t,r,o),!a)throw new f(`Graph.${i}: could not find an edge for the given path ("${t}" - "${r}").`)}else{if("mixed"!==o)throw new l(`Graph.${i}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,a=this._edges.get(e),!a)throw new f(`Graph.${i}: could not find the "${e}" edge in the graph.`)}if(!r(s))throw new p(`Graph.${i}: provided attributes are not a plain object.`);return t(a.attributes,s),this.emit("edgeAttributesUpdated",{key:a.key,type:"merge",attributes:a.attributes,data:s}),this}}},{name:e=>`update${e}Attributes`,attacher:function(e,t,i){e.prototype[t]=function(e,r){let o;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new l(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new l(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+e,a=""+r;if(r=arguments[2],o=n(this,s,a,i),!o)throw new f(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if("mixed"!==i)throw new l(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,o=this._edges.get(e),!o)throw new f(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if("function"!=typeof r)throw new p(`Graph.${t}: provided updater is not a function.`);return o.attributes=r(o.attributes),this.emit("edgeAttributesUpdated",{key:o.key,type:"update",attributes:o.attributes}),this}}}],k=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function E(e,t,i,n){let r=!1;for(const o in t){if(o===n)continue;const s=t[o];if(r=i(s.key,s.attributes,s.source.key,s.target.key,s.source.attributes,s.target.attributes,s.undirected),e&&r)return s.key}}function $(e,t,i,n){let r,o,s,a=!1;for(const d in t)if(d!==n){r=t[d];do{if(o=r.source,s=r.target,a=i(r.key,r.attributes,o.key,s.key,o.attributes,s.attributes,r.undirected),e&&a)return r.key;r=r.next}while(void 0!==r)}}function x(e,t){const i=Object.keys(e),n=i.length;let r,o=0;return{[Symbol.iterator](){return this},next(){do{if(r)r=r.next;else{if(o>=n)return{done:!0};const s=i[o++];if(s===t){r=void 0;continue}r=e[s]}}while(!r);return{done:!1,value:{edge:r.key,attributes:r.attributes,source:r.source.key,target:r.target.key,sourceAttributes:r.source.attributes,targetAttributes:r.target.attributes,undirected:r.undirected}}}}}function G(e,t,i,n){const r=t[i];if(!r)return;const o=r.source,s=r.target;return n(r.key,r.attributes,o.key,s.key,o.attributes,s.attributes,r.undirected)&&e?r.key:void 0}function A(e,t,i,n){let r=t[i];if(!r)return;let o=!1;do{if(o=n(r.key,r.attributes,r.source.key,r.target.key,r.source.attributes,r.target.attributes,r.undirected),e&&o)return r.key;r=r.next}while(void 0!==r)}function S(e,t){let i=e[t];if(void 0!==i.next)return{[Symbol.iterator](){return this},next(){if(!i)return{done:!0};const e={edge:i.key,attributes:i.attributes,source:i.source.key,target:i.target.key,sourceAttributes:i.source.attributes,targetAttributes:i.target.attributes,undirected:i.undirected};return i=i.next,{done:!1,value:e}}};let n=!1;return{[Symbol.iterator](){return this},next:()=>!0===n?{done:!0}:(n=!0,{done:!1,value:{edge:i.key,attributes:i.attributes,source:i.source.key,target:i.target.key,sourceAttributes:i.source.attributes,targetAttributes:i.target.attributes,undirected:i.undirected}})}}function L(e,t,i,n){if(0===t.size)return;const r="mixed"!==i&&i!==t.type,o="undirected"===i;let s,a,d=!1;const u=t._edges.values();for(;s=u.next(),!0!==s.done;){if(a=s.value,r&&a.undirected!==o)continue;const{key:t,attributes:i,source:u,target:h}=a;if(d=n(t,i,u.key,h.key,u.attributes,h.attributes,a.undirected),e&&d)return t}}function D(e,t,i,n,r,o){const s=t?$:E;let a;if("undirected"!==i){if("out"!==n&&(a=s(e,r.in,o),e&&a))return a;if("in"!==n&&(a=s(e,r.out,o,n?void 0:r.key),e&&a))return a}if("directed"!==i&&(a=s(e,r.undirected,o),e&&a))return a}function C(e,t,i,n,r,o,s){const a=i?A:G;let d;if("undirected"!==t){if(void 0!==r.in&&"out"!==n&&(d=a(e,r.in,o,s),e&&d))return d;if(void 0!==r.out&&"in"!==n&&(n||r.key!==o)&&(d=a(e,r.out,o,s),e&&d))return d}if("directed"!==t&&void 0!==r.undirected&&(d=a(e,r.undirected,o,s),e&&d))return d}const O=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function M(){this.A=null,this.B=null}function R(e,t,i,n,r){for(const o in n){const s=n[o],a=s.source,d=s.target,u=a===i?d:a;if(t&&t.has(u.key))continue;const h=r(u.key,u.attributes);if(e&&h)return u.key}}function U(e,t,i,n,r){if("mixed"!==t){if("undirected"===t)return R(e,null,n,n.undirected,r);if("string"==typeof i)return R(e,null,n,n[i],r)}const o=new M;let s;if("undirected"!==t){if("out"!==i){if(s=R(e,null,n,n.in,r),e&&s)return s;o.wrap(n.in)}if("in"!==i){if(s=R(e,o,n,n.out,r),e&&s)return s;o.wrap(n.out)}}if("directed"!==t&&(s=R(e,o,n,n.undirected,r),e&&s))return s}function N(e,t,i){const n=Object.keys(i),r=n.length;let o=0;return{[Symbol.iterator](){return this},next(){let s=null;do{if(o>=r)return e&&e.wrap(i),{done:!0};const a=i[n[o++]],d=a.source,u=a.target;s=d===t?u:d,e&&e.has(s.key)&&(s=null)}while(null===s);return{done:!1,value:{neighbor:s.key,attributes:s.attributes}}}}}function j(e,t,i,n,r){const o=n._nodes.values(),s=n.type;let a,d,u,h,c,p,f;for(;a=o.next(),!0!==a.done;){let n=!1;if(d=a.value,"undirected"!==s)for(u in h=d.out,h){c=h[u];do{if(p=c.target,n=!0,f=r(d.key,p.key,d.attributes,p.attributes,c.key,c.attributes,c.undirected),e&&f)return c;c=c.next}while(c)}if("directed"!==s)for(u in h=d.undirected,h)if(!(t&&d.key>u)){c=h[u];do{if(p=c.target,p.key!==u&&(p=c.source),n=!0,f=r(d.key,p.key,d.attributes,p.attributes,c.key,c.attributes,c.undirected),e&&f)return c;c=c.next}while(c)}if(i&&!n&&(f=r(d.key,null,d.attributes,null,null,null,null),e&&f))return null}}function z(e){if(!r(e))throw new p('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in e))throw new p("Graph.import: serialized node is missing its key.");if("attributes"in e&&(!r(e.attributes)||null===e.attributes))throw new p("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function T(e){if(!r(e))throw new p('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in e))throw new p("Graph.import: serialized edge is missing its source.");if(!("target"in e))throw new p("Graph.import: serialized edge is missing its target.");if("attributes"in e&&(!r(e.attributes)||null===e.attributes))throw new p("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in e&&"boolean"!=typeof e.undirected)throw new p("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}M.prototype.wrap=function(e){null===this.A?this.A=e:null===this.B&&(this.B=e)},M.prototype.has=function(e){return null!==this.A&&e in this.A||null!==this.B&&e in this.B};const I=function(){let e=255&Math.floor(256*Math.random());return()=>e++}(),W=new Set(["directed","undirected","mixed"]),F=new Set(["domain","_events","_eventsCount","_maxListeners"]),P={allowSelfLoops:!0,multi:!1,type:"mixed"};function q(e,t,i){const n=new e.NodeDataClass(t,i);return e._nodes.set(t,n),e.emit("nodeAdded",{key:t,attributes:i}),n}function K(e,t,i,n,o,s,a,d){if(!n&&"undirected"===e.type)throw new l(`Graph.${t}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);if(n&&"directed"===e.type)throw new l(`Graph.${t}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);if(d&&!r(d))throw new p(`Graph.${t}: invalid attributes. Expecting an object but got "${d}"`);if(s=""+s,a=""+a,d=d||{},!e.allowSelfLoops&&s===a)throw new l(`Graph.${t}: source & target are the same ("${s}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);const u=e._nodes.get(s),h=e._nodes.get(a);if(!u)throw new f(`Graph.${t}: source node "${s}" not found.`);if(!h)throw new f(`Graph.${t}: target node "${a}" not found.`);const c={key:null,undirected:n,source:s,target:a,attributes:d};if(i)o=e._edgeKeyGenerator();else if(o=""+o,e._edges.has(o))throw new l(`Graph.${t}: the "${o}" edge already exists in the graph.`);if(!e.multi&&(n?void 0!==u.undirected[a]:void 0!==u.out[a]))throw new l(`Graph.${t}: an edge linking "${s}" to "${a}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);const g=new w(n,o,u,h,d);e._edges.set(o,g);const y=s===a;return n?(u.undirectedDegree++,h.undirectedDegree++,y&&(u.undirectedLoops++,e._undirectedSelfLoopCount++)):(u.outDegree++,h.inDegree++,y&&(u.directedLoops++,e._directedSelfLoopCount++)),e.multi?g.attachMulti():g.attach(),n?e._undirectedSize++:e._directedSize++,c.key=o,e.emit("edgeAdded",c),o}function H(e,i,n,o,s,a,d,u,h){if(!o&&"undirected"===e.type)throw new l(`Graph.${i}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`);if(o&&"directed"===e.type)throw new l(`Graph.${i}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`);if(u)if(h){if("function"!=typeof u)throw new p(`Graph.${i}: invalid updater function. Expecting a function but got "${u}"`)}else if(!r(u))throw new p(`Graph.${i}: invalid attributes. Expecting an object but got "${u}"`);let c;if(a=""+a,d=""+d,h&&(c=u,u=void 0),!e.allowSelfLoops&&a===d)throw new l(`Graph.${i}: source & target are the same ("${a}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let f,g,y=e._nodes.get(a),m=e._nodes.get(d);if(!n&&(f=e._edges.get(s),f)){if(!(f.source.key===a&&f.target.key===d||o&&f.source.key===d&&f.target.key===a))throw new l(`Graph.${i}: inconsistency detected when attempting to merge the "${s}" edge with "${a}" source & "${d}" target vs. ("${f.source.key}", "${f.target.key}").`);g=f}if(g||e.multi||!y||(g=o?y.undirected[d]:y.out[d]),g){const i=[g.key,!1,!1,!1];if(h?!c:!u)return i;if(h){const t=g.attributes;g.attributes=c(t),e.emit("edgeAttributesUpdated",{type:"replace",key:g.key,attributes:g.attributes})}else t(g.attributes,u),e.emit("edgeAttributesUpdated",{type:"merge",key:g.key,attributes:g.attributes,data:u});return i}u=u||{},h&&c&&(u=c(u));const b={key:null,undirected:o,source:a,target:d,attributes:u};if(n)s=e._edgeKeyGenerator();else if(s=""+s,e._edges.has(s))throw new l(`Graph.${i}: the "${s}" edge already exists in the graph.`);let v=!1,_=!1;y||(y=q(e,a,{}),v=!0,a===d&&(m=y,_=!0)),m||(m=q(e,d,{}),_=!0),f=new w(o,s,y,m,u),e._edges.set(s,f);const k=a===d;return o?(y.undirectedDegree++,m.undirectedDegree++,k&&(y.undirectedLoops++,e._undirectedSelfLoopCount++)):(y.outDegree++,m.inDegree++,k&&(y.directedLoops++,e._directedSelfLoopCount++)),e.multi?f.attachMulti():f.attach(),o?e._undirectedSize++:e._directedSize++,b.key=s,e.emit("edgeAdded",b),[s,!0,v,_]}function B(e,t){e._edges.delete(t.key);const{source:i,target:n,attributes:r}=t,o=t.undirected,s=i===n;o?(i.undirectedDegree--,n.undirectedDegree--,s&&(i.undirectedLoops--,e._undirectedSelfLoopCount--)):(i.outDegree--,n.inDegree--,s&&(i.directedLoops--,e._directedSelfLoopCount--)),e.multi?t.detachMulti():t.detach(),o?e._undirectedSize--:e._directedSize--,e.emit("edgeDropped",{key:t.key,attributes:r,source:i.key,target:n.key,undirected:o})}class Y extends e.EventEmitter{constructor(e){if(super(),"boolean"!=typeof(e=t({},P,e)).multi)throw new p(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${e.multi}".`);if(!W.has(e.type))throw new p(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${e.type}".`);if("boolean"!=typeof e.allowSelfLoops)throw new p(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${e.allowSelfLoops}".`);s(this,"NodeDataClass","mixed"===e.type?g:"directed"===e.type?y:m);const i="geid_"+I()+"_";let n=0;s(this,"_attributes",{}),s(this,"_nodes",new Map),s(this,"_edges",new Map),s(this,"_directedSize",0),s(this,"_undirectedSize",0),s(this,"_directedSelfLoopCount",0),s(this,"_undirectedSelfLoopCount",0),s(this,"_edgeKeyGenerator",(()=>{let e;do{e=i+n++}while(this._edges.has(e));return e})),s(this,"_options",e),F.forEach((e=>s(this,e,this[e]))),a(this,"order",(()=>this._nodes.size)),a(this,"size",(()=>this._edges.size)),a(this,"directedSize",(()=>this._directedSize)),a(this,"undirectedSize",(()=>this._undirectedSize)),a(this,"selfLoopCount",(()=>this._directedSelfLoopCount+this._undirectedSelfLoopCount)),a(this,"directedSelfLoopCount",(()=>this._directedSelfLoopCount)),a(this,"undirectedSelfLoopCount",(()=>this._undirectedSelfLoopCount)),a(this,"multi",this._options.multi),a(this,"type",this._options.type),a(this,"allowSelfLoops",this._options.allowSelfLoops),a(this,"implementation",(()=>"graphology"))}_resetInstanceCounters(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0}hasNode(e){return this._nodes.has(""+e)}hasDirectedEdge(e,t){if("undirected"===this.type)return!1;if(1===arguments.length){const t=""+e,i=this._edges.get(t);return!!i&&!i.undirected}if(2===arguments.length){e=""+e,t=""+t;const i=this._nodes.get(e);return!!i&&i.out.hasOwnProperty(t)}throw new p(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasUndirectedEdge(e,t){if("directed"===this.type)return!1;if(1===arguments.length){const t=""+e,i=this._edges.get(t);return!!i&&i.undirected}if(2===arguments.length){e=""+e,t=""+t;const i=this._nodes.get(e);return!!i&&i.undirected.hasOwnProperty(t)}throw new p(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasEdge(e,t){if(1===arguments.length){const t=""+e;return this._edges.has(t)}if(2===arguments.length){e=""+e,t=""+t;const i=this._nodes.get(e);return!!i&&(void 0!==i.out&&i.out.hasOwnProperty(t)||void 0!==i.undirected&&i.undirected.hasOwnProperty(t))}throw new p(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}directedEdge(e,t){if("undirected"===this.type)return;if(e=""+e,t=""+t,this.multi)throw new l("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");const i=this._nodes.get(e);if(!i)throw new f(`Graph.directedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new f(`Graph.directedEdge: could not find the "${t}" target node in the graph.`);const n=i.out&&i.out[t]||void 0;return n?n.key:void 0}undirectedEdge(e,t){if("directed"===this.type)return;if(e=""+e,t=""+t,this.multi)throw new l("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");const i=this._nodes.get(e);if(!i)throw new f(`Graph.undirectedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new f(`Graph.undirectedEdge: could not find the "${t}" target node in the graph.`);const n=i.undirected&&i.undirected[t]||void 0;return n?n.key:void 0}edge(e,t){if(this.multi)throw new l("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");e=""+e,t=""+t;const i=this._nodes.get(e);if(!i)throw new f(`Graph.edge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new f(`Graph.edge: could not find the "${t}" target node in the graph.`);const n=i.out&&i.out[t]||i.undirected&&i.undirected[t]||void 0;if(n)return n.key}areDirectedNeighbors(e,t){e=""+e,t=""+t;const i=this._nodes.get(e);if(!i)throw new f(`Graph.areDirectedNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&(t in i.in||t in i.out)}areOutNeighbors(e,t){e=""+e,t=""+t;const i=this._nodes.get(e);if(!i)throw new f(`Graph.areOutNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in i.out}areInNeighbors(e,t){e=""+e,t=""+t;const i=this._nodes.get(e);if(!i)throw new f(`Graph.areInNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in i.in}areUndirectedNeighbors(e,t){e=""+e,t=""+t;const i=this._nodes.get(e);if(!i)throw new f(`Graph.areUndirectedNeighbors: could not find the "${e}" node in the graph.`);return"directed"!==this.type&&t in i.undirected}areNeighbors(e,t){e=""+e,t=""+t;const i=this._nodes.get(e);if(!i)throw new f(`Graph.areNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&(t in i.in||t in i.out)||"directed"!==this.type&&t in i.undirected}areInboundNeighbors(e,t){e=""+e,t=""+t;const i=this._nodes.get(e);if(!i)throw new f(`Graph.areInboundNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in i.in||"directed"!==this.type&&t in i.undirected}areOutboundNeighbors(e,t){e=""+e,t=""+t;const i=this._nodes.get(e);if(!i)throw new f(`Graph.areOutboundNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in i.out||"directed"!==this.type&&t in i.undirected}inDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new f(`Graph.inDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree}outDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new f(`Graph.outDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.outDegree}directedDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new f(`Graph.directedDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree+t.outDegree}undirectedDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new f(`Graph.undirectedDegree: could not find the "${e}" node in the graph.`);return"directed"===this.type?0:t.undirectedDegree}inboundDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new f(`Graph.inboundDegree: could not find the "${e}" node in the graph.`);let i=0;return"directed"!==this.type&&(i+=t.undirectedDegree),"undirected"!==this.type&&(i+=t.inDegree),i}outboundDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new f(`Graph.outboundDegree: could not find the "${e}" node in the graph.`);let i=0;return"directed"!==this.type&&(i+=t.undirectedDegree),"undirected"!==this.type&&(i+=t.outDegree),i}degree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new f(`Graph.degree: could not find the "${e}" node in the graph.`);let i=0;return"directed"!==this.type&&(i+=t.undirectedDegree),"undirected"!==this.type&&(i+=t.inDegree+t.outDegree),i}inDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new f(`Graph.inDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree-t.directedLoops}outDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new f(`Graph.outDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.outDegree-t.directedLoops}directedDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new f(`Graph.directedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree+t.outDegree-2*t.directedLoops}undirectedDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new f(`Graph.undirectedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"directed"===this.type?0:t.undirectedDegree-2*t.undirectedLoops}inboundDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new f(`Graph.inboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let i=0,n=0;return"directed"!==this.type&&(i+=t.undirectedDegree,n+=2*t.undirectedLoops),"undirected"!==this.type&&(i+=t.inDegree,n+=t.directedLoops),i-n}outboundDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new f(`Graph.outboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let i=0,n=0;return"directed"!==this.type&&(i+=t.undirectedDegree,n+=2*t.undirectedLoops),"undirected"!==this.type&&(i+=t.outDegree,n+=t.directedLoops),i-n}degreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new f(`Graph.degreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let i=0,n=0;return"directed"!==this.type&&(i+=t.undirectedDegree,n+=2*t.undirectedLoops),"undirected"!==this.type&&(i+=t.inDegree+t.outDegree,n+=2*t.directedLoops),i-n}source(e){e=""+e;const t=this._edges.get(e);if(!t)throw new f(`Graph.source: could not find the "${e}" edge in the graph.`);return t.source.key}target(e){e=""+e;const t=this._edges.get(e);if(!t)throw new f(`Graph.target: could not find the "${e}" edge in the graph.`);return t.target.key}extremities(e){e=""+e;const t=this._edges.get(e);if(!t)throw new f(`Graph.extremities: could not find the "${e}" edge in the graph.`);return[t.source.key,t.target.key]}opposite(e,t){e=""+e,t=""+t;const i=this._edges.get(t);if(!i)throw new f(`Graph.opposite: could not find the "${t}" edge in the graph.`);const n=i.source.key,r=i.target.key;if(e===n)return r;if(e===r)return n;throw new f(`Graph.opposite: the "${e}" node is not attached to the "${t}" edge (${n}, ${r}).`)}hasExtremity(e,t){e=""+e,t=""+t;const i=this._edges.get(e);if(!i)throw new f(`Graph.hasExtremity: could not find the "${e}" edge in the graph.`);return i.source.key===t||i.target.key===t}isUndirected(e){e=""+e;const t=this._edges.get(e);if(!t)throw new f(`Graph.isUndirected: could not find the "${e}" edge in the graph.`);return t.undirected}isDirected(e){e=""+e;const t=this._edges.get(e);if(!t)throw new f(`Graph.isDirected: could not find the "${e}" edge in the graph.`);return!t.undirected}isSelfLoop(e){e=""+e;const t=this._edges.get(e);if(!t)throw new f(`Graph.isSelfLoop: could not find the "${e}" edge in the graph.`);return t.source===t.target}addNode(e,t){const i=function(e,t,i){if(i&&!r(i))throw new p(`Graph.addNode: invalid attributes. Expecting an object but got "${i}"`);if(t=""+t,i=i||{},e._nodes.has(t))throw new l(`Graph.addNode: the "${t}" node already exist in the graph.`);const n=new e.NodeDataClass(t,i);return e._nodes.set(t,n),e.emit("nodeAdded",{key:t,attributes:i}),n}(this,e,t);return i.key}mergeNode(e,i){if(i&&!r(i))throw new p(`Graph.mergeNode: invalid attributes. Expecting an object but got "${i}"`);e=""+e,i=i||{};let n=this._nodes.get(e);return n?(i&&(t(n.attributes,i),this.emit("nodeAttributesUpdated",{type:"merge",key:e,attributes:n.attributes,data:i})),[e,!1]):(n=new this.NodeDataClass(e,i),this._nodes.set(e,n),this.emit("nodeAdded",{key:e,attributes:i}),[e,!0])}updateNode(e,t){if(t&&"function"!=typeof t)throw new p(`Graph.updateNode: invalid updater function. Expecting a function but got "${t}"`);e=""+e;let i=this._nodes.get(e);if(i){if(t){const n=i.attributes;i.attributes=t(n),this.emit("nodeAttributesUpdated",{type:"replace",key:e,attributes:i.attributes})}return[e,!1]}const n=t?t({}):{};return i=new this.NodeDataClass(e,n),this._nodes.set(e,i),this.emit("nodeAdded",{key:e,attributes:n}),[e,!0]}dropNode(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new f(`Graph.dropNode: could not find the "${e}" node in the graph.`);let i;if("undirected"!==this.type){for(const e in t.out){i=t.out[e];do{B(this,i),i=i.next}while(i)}for(const e in t.in){i=t.in[e];do{B(this,i),i=i.next}while(i)}}if("directed"!==this.type)for(const e in t.undirected){i=t.undirected[e];do{B(this,i),i=i.next}while(i)}this._nodes.delete(e),this.emit("nodeDropped",{key:e,attributes:t.attributes})}dropEdge(e){let t;if(arguments.length>1){const e=""+arguments[0],i=""+arguments[1];if(t=n(this,e,i,this.type),!t)throw new f(`Graph.dropEdge: could not find the "${e}" -> "${i}" edge in the graph.`)}else if(e=""+e,t=this._edges.get(e),!t)throw new f(`Graph.dropEdge: could not find the "${e}" edge in the graph.`);return B(this,t),this}dropDirectedEdge(e,t){if(arguments.length<2)throw new l("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new l("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");const i=n(this,e=""+e,t=""+t,"directed");if(!i)throw new f(`Graph.dropDirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return B(this,i),this}dropUndirectedEdge(e,t){if(arguments.length<2)throw new l("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new l("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");const i=n(this,e,t,"undirected");if(!i)throw new f(`Graph.dropUndirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return B(this,i),this}clear(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")}clearEdges(){const e=this._nodes.values();let t;for(;t=e.next(),!0!==t.done;)t.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")}getAttribute(e){return this._attributes[e]}getAttributes(){return this._attributes}hasAttribute(e){return this._attributes.hasOwnProperty(e)}setAttribute(e,t){return this._attributes[e]=t,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}updateAttribute(e,t){if("function"!=typeof t)throw new p("Graph.updateAttribute: updater should be a function.");const i=this._attributes[e];return this._attributes[e]=t(i),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}removeAttribute(e){return delete this._attributes[e],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:e}),this}replaceAttributes(e){if(!r(e))throw new p("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=e,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this}mergeAttributes(e){if(!r(e))throw new p("Graph.mergeAttributes: provided attributes are not a plain object.");return t(this._attributes,e),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:e}),this}updateAttributes(e){if("function"!=typeof e)throw new p("Graph.updateAttributes: provided updater is not a function.");return this._attributes=e(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this}updateEachNodeAttributes(e,t){if("function"!=typeof e)throw new p("Graph.updateEachNodeAttributes: expecting an updater function.");if(t&&!d(t))throw new p("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const i=this._nodes.values();let n,r;for(;n=i.next(),!0!==n.done;)r=n.value,r.attributes=e(r.key,r.attributes);this.emit("eachNodeAttributesUpdated",{hints:t||null})}updateEachEdgeAttributes(e,t){if("function"!=typeof e)throw new p("Graph.updateEachEdgeAttributes: expecting an updater function.");if(t&&!d(t))throw new p("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const i=this._edges.values();let n,r,o,s;for(;n=i.next(),!0!==n.done;)r=n.value,o=r.source,s=r.target,r.attributes=e(r.key,r.attributes,o.key,s.key,o.attributes,s.attributes,r.undirected);this.emit("eachEdgeAttributesUpdated",{hints:t||null})}forEachAdjacencyEntry(e){if("function"!=typeof e)throw new p("Graph.forEachAdjacencyEntry: expecting a callback.");j(!1,!1,!1,this,e)}forEachAdjacencyEntryWithOrphans(e){if("function"!=typeof e)throw new p("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");j(!1,!1,!0,this,e)}forEachAssymetricAdjacencyEntry(e){if("function"!=typeof e)throw new p("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");j(!1,!0,!1,this,e)}forEachAssymetricAdjacencyEntryWithOrphans(e){if("function"!=typeof e)throw new p("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");j(!1,!0,!0,this,e)}nodes(){return Array.from(this._nodes.keys())}forEachNode(e){if("function"!=typeof e)throw new p("Graph.forEachNode: expecting a callback.");const t=this._nodes.values();let i,n;for(;i=t.next(),!0!==i.done;)n=i.value,e(n.key,n.attributes)}findNode(e){if("function"!=typeof e)throw new p("Graph.findNode: expecting a callback.");const t=this._nodes.values();let i,n;for(;i=t.next(),!0!==i.done;)if(n=i.value,e(n.key,n.attributes))return n.key}mapNodes(e){if("function"!=typeof e)throw new p("Graph.mapNode: expecting a callback.");const t=this._nodes.values();let i,n;const r=new Array(this.order);let o=0;for(;i=t.next(),!0!==i.done;)n=i.value,r[o++]=e(n.key,n.attributes);return r}someNode(e){if("function"!=typeof e)throw new p("Graph.someNode: expecting a callback.");const t=this._nodes.values();let i,n;for(;i=t.next(),!0!==i.done;)if(n=i.value,e(n.key,n.attributes))return!0;return!1}everyNode(e){if("function"!=typeof e)throw new p("Graph.everyNode: expecting a callback.");const t=this._nodes.values();let i,n;for(;i=t.next(),!0!==i.done;)if(n=i.value,!e(n.key,n.attributes))return!1;return!0}filterNodes(e){if("function"!=typeof e)throw new p("Graph.filterNodes: expecting a callback.");const t=this._nodes.values();let i,n;const r=[];for(;i=t.next(),!0!==i.done;)n=i.value,e(n.key,n.attributes)&&r.push(n.key);return r}reduceNodes(e,t){if("function"!=typeof e)throw new p("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new p("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");let i=t;const n=this._nodes.values();let r,o;for(;r=n.next(),!0!==r.done;)o=r.value,i=e(i,o.key,o.attributes);return i}nodeEntries(){const e=this._nodes.values();return{[Symbol.iterator](){return this},next(){const t=e.next();if(t.done)return t;const i=t.value;return{value:{node:i.key,attributes:i.attributes},done:!1}}}}export(){const e=new Array(this._nodes.size);let i=0;this._nodes.forEach(((n,r)=>{e[i++]=function(e,i){const n={key:e};return o(i.attributes)||(n.attributes=t({},i.attributes)),n}(r,n)}));const n=new Array(this._edges.size);return i=0,this._edges.forEach(((e,r)=>{n[i++]=function(e,i,n){const r={key:i,source:n.source.key,target:n.target.key};return o(n.attributes)||(r.attributes=t({},n.attributes)),"mixed"===e&&n.undirected&&(r.undirected=!0),r}(this.type,r,e)})),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:e,edges:n}}import(e,t=!1){if(e instanceof Y)return e.forEachNode(((e,i)=>{t?this.mergeNode(e,i):this.addNode(e,i)})),e.forEachEdge(((e,i,n,r,o,s,a)=>{t?a?this.mergeUndirectedEdgeWithKey(e,n,r,i):this.mergeDirectedEdgeWithKey(e,n,r,i):a?this.addUndirectedEdgeWithKey(e,n,r,i):this.addDirectedEdgeWithKey(e,n,r,i)})),this;if(!r(e))throw new p("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(e.attributes){if(!r(e.attributes))throw new p("Graph.import: invalid attributes. Expecting a plain object.");t?this.mergeAttributes(e.attributes):this.replaceAttributes(e.attributes)}let i,n,o,s,a;if(e.nodes){if(o=e.nodes,!Array.isArray(o))throw new p("Graph.import: invalid nodes. Expecting an array.");for(i=0,n=o.length;i<n;i++){s=o[i],z(s);const{key:e,attributes:n}=s;t?this.mergeNode(e,n):this.addNode(e,n)}}if(e.edges){let r=!1;if("undirected"===this.type&&(r=!0),o=e.edges,!Array.isArray(o))throw new p("Graph.import: invalid edges. Expecting an array.");for(i=0,n=o.length;i<n;i++){a=o[i],T(a);const{source:e,target:n,attributes:s,undirected:d=r}=a;let u;"key"in a?(u=t?d?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:d?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey,u.call(this,a.key,e,n,s)):(u=t?d?this.mergeUndirectedEdge:this.mergeDirectedEdge:d?this.addUndirectedEdge:this.addDirectedEdge,u.call(this,e,n,s))}}return this}nullCopy(e){const i=new Y(t({},this._options,e));return i.replaceAttributes(t({},this.getAttributes())),i}emptyCopy(e){const i=this.nullCopy(e);return this._nodes.forEach(((e,n)=>{const r=t({},e.attributes);e=new i.NodeDataClass(n,r),i._nodes.set(n,e)})),i}copy(e){if("string"==typeof(e=e||{}).type&&e.type!==this.type&&"mixed"!==e.type)throw new l(`Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${e.type}" because this would mean losing information about the current graph.`);if("boolean"==typeof e.multi&&e.multi!==this.multi&&!0!==e.multi)throw new l("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if("boolean"==typeof e.allowSelfLoops&&e.allowSelfLoops!==this.allowSelfLoops&&!0!==e.allowSelfLoops)throw new l("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");const i=this.emptyCopy(e),n=this._edges.values();let r,o;for(;r=n.next(),!0!==r.done;)o=r.value,K(i,"copy",!1,o.undirected,o.key,o.source.key,o.target.key,t({},o.attributes));return i}toJSON(){return this.export()}toString(){return"[object Graph]"}inspect(){const e={};this._nodes.forEach(((t,i)=>{e[i]=t.attributes}));const t={},i={};this._edges.forEach(((e,n)=>{const r=e.undirected?"--":"->";let o,s="",a=e.source.key,d=e.target.key;e.undirected&&a>d&&(o=a,a=d,d=o);const u=`(${a})${r}(${d})`;n.startsWith("geid_")?this.multi&&(void 0===i[u]?i[u]=0:i[u]++,s+=`${i[u]}. `):s+=`[${n}]: `,s+=u,t[s]=e.attributes}));const n={};for(const e in this)this.hasOwnProperty(e)&&!F.has(e)&&"function"!=typeof this[e]&&"symbol"!=typeof e&&(n[e]=this[e]);return n.attributes=this._attributes,n.nodes=e,n.edges=t,s(n,"constructor",this.constructor),n}}"undefined"!=typeof Symbol&&(Y.prototype[Symbol.for("nodejs.util.inspect.custom")]=Y.prototype.inspect),[{name:e=>`${e}Edge`,generateKey:!0},{name:e=>`${e}DirectedEdge`,generateKey:!0,type:"directed"},{name:e=>`${e}UndirectedEdge`,generateKey:!0,type:"undirected"},{name:e=>`${e}EdgeWithKey`},{name:e=>`${e}DirectedEdgeWithKey`,type:"directed"},{name:e=>`${e}UndirectedEdgeWithKey`,type:"undirected"}].forEach((e=>{["add","merge","update"].forEach((t=>{const i=e.name(t),n="add"===t?K:H;e.generateKey?Y.prototype[i]=function(r,o,s){return n(this,i,!0,"undirected"===(e.type||this.type),null,r,o,s,"update"===t)}:Y.prototype[i]=function(r,o,s,a){return n(this,i,!1,"undirected"===(e.type||this.type),r,o,s,a,"update"===t)}}))})),function(e){v.forEach((function({name:t,attacher:i}){i(e,t("Node"),0),i(e,t("Source"),1),i(e,t("Target"),2),i(e,t("Opposite"),3)}))}(Y),function(e){_.forEach((function({name:t,attacher:i}){i(e,t("Edge"),"mixed"),i(e,t("DirectedEdge"),"directed"),i(e,t("UndirectedEdge"),"undirected")}))}(Y),function(e){k.forEach((t=>{(function(e,t){const{name:i,type:n,direction:r}=t;e.prototype[i]=function(e,t){if("mixed"!==n&&"mixed"!==this.type&&n!==this.type)return[];if(!arguments.length)return function(e,t){if(0===e.size)return[];if("mixed"===t||t===e.type)return Array.from(e._edges.keys());const i="undirected"===t?e.undirectedSize:e.directedSize,n=new Array(i),r="undirected"===t,o=e._edges.values();let s,a,d=0;for(;s=o.next(),!0!==s.done;)a=s.value,a.undirected===r&&(n[d++]=a.key);return n}(this,n);if(1===arguments.length){e=""+e;const t=this._nodes.get(e);if(void 0===t)throw new f(`Graph.${i}: could not find the "${e}" node in the graph.`);return function(e,t,i,n){const r=[];return D(!1,e,t,i,n,(function(e){r.push(e)})),r}(this.multi,"mixed"===n?this.type:n,r,t)}if(2===arguments.length){e=""+e,t=""+t;const o=this._nodes.get(e);if(!o)throw new f(`Graph.${i}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new f(`Graph.${i}:  could not find the "${t}" target node in the graph.`);return function(e,t,i,n,r){const o=[];return C(!1,e,t,i,n,r,(function(e){o.push(e)})),o}(n,this.multi,r,o,t)}throw new p(`Graph.${i}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}})(e,t),function(e,t){const{name:i,type:n,direction:r}=t,o="forEach"+i[0].toUpperCase()+i.slice(1,-1);e.prototype[o]=function(e,t,i){if("mixed"===n||"mixed"===this.type||n===this.type){if(1===arguments.length)return L(!1,this,n,i=e);if(2===arguments.length){e=""+e,i=t;const s=this._nodes.get(e);if(void 0===s)throw new f(`Graph.${o}: could not find the "${e}" node in the graph.`);return D(!1,this.multi,"mixed"===n?this.type:n,r,s,i)}if(3===arguments.length){e=""+e,t=""+t;const s=this._nodes.get(e);if(!s)throw new f(`Graph.${o}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new f(`Graph.${o}:  could not find the "${t}" target node in the graph.`);return C(!1,n,this.multi,r,s,t,i)}throw new p(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)}};const s="map"+i[0].toUpperCase()+i.slice(1);e.prototype[s]=function(){const e=Array.prototype.slice.call(arguments),t=e.pop();let i;if(0===e.length){let r=0;"directed"!==n&&(r+=this.undirectedSize),"undirected"!==n&&(r+=this.directedSize),i=new Array(r);let o=0;e.push(((e,n,r,s,a,d,u)=>{i[o++]=t(e,n,r,s,a,d,u)}))}else i=[],e.push(((e,n,r,o,s,a,d)=>{i.push(t(e,n,r,o,s,a,d))}));return this[o].apply(this,e),i};const a="filter"+i[0].toUpperCase()+i.slice(1);e.prototype[a]=function(){const e=Array.prototype.slice.call(arguments),t=e.pop(),i=[];return e.push(((e,n,r,o,s,a,d)=>{t(e,n,r,o,s,a,d)&&i.push(e)})),this[o].apply(this,e),i};const d="reduce"+i[0].toUpperCase()+i.slice(1);e.prototype[d]=function(){let e,t,i=Array.prototype.slice.call(arguments);if(i.length<2||i.length>4)throw new p(`Graph.${d}: invalid number of arguments (expecting 2, 3 or 4 and got ${i.length}).`);if("function"==typeof i[i.length-1]&&"function"!=typeof i[i.length-2])throw new p(`Graph.${d}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);2===i.length?(e=i[0],t=i[1],i=[]):3===i.length?(e=i[1],t=i[2],i=[i[0]]):4===i.length&&(e=i[2],t=i[3],i=[i[0],i[1]]);let n=t;return i.push(((t,i,r,o,s,a,d)=>{n=e(n,t,i,r,o,s,a,d)})),this[o].apply(this,i),n}}(e,t),function(e,t){const{name:i,type:n,direction:r}=t,o="find"+i[0].toUpperCase()+i.slice(1,-1);e.prototype[o]=function(e,t,i){if("mixed"!==n&&"mixed"!==this.type&&n!==this.type)return!1;if(1===arguments.length)return L(!0,this,n,i=e);if(2===arguments.length){e=""+e,i=t;const s=this._nodes.get(e);if(void 0===s)throw new f(`Graph.${o}: could not find the "${e}" node in the graph.`);return D(!0,this.multi,"mixed"===n?this.type:n,r,s,i)}if(3===arguments.length){e=""+e,t=""+t;const s=this._nodes.get(e);if(!s)throw new f(`Graph.${o}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new f(`Graph.${o}:  could not find the "${t}" target node in the graph.`);return C(!0,n,this.multi,r,s,t,i)}throw new p(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)};const s="some"+i[0].toUpperCase()+i.slice(1,-1);e.prototype[s]=function(){const e=Array.prototype.slice.call(arguments),t=e.pop();return e.push(((e,i,n,r,o,s,a)=>t(e,i,n,r,o,s,a))),!!this[o].apply(this,e)};const a="every"+i[0].toUpperCase()+i.slice(1,-1);e.prototype[a]=function(){const e=Array.prototype.slice.call(arguments),t=e.pop();return e.push(((e,i,n,r,o,s,a)=>!t(e,i,n,r,o,s,a))),!this[o].apply(this,e)}}(e,t),function(e,t){const{name:i,type:n,direction:r}=t,o=i.slice(0,-1)+"Entries";e.prototype[o]=function(e,t){if("mixed"!==n&&"mixed"!==this.type&&n!==this.type)return h();if(!arguments.length)return function(e,t){if(0===e.size)return h();const i="mixed"!==t&&t!==e.type,n="undirected"===t,r=e._edges.values();return{[Symbol.iterator](){return this},next(){let e,t;for(;;){if(e=r.next(),e.done)return e;if(t=e.value,!i||t.undirected===n)break}return{value:{edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected},done:!1}}}}(this,n);if(1===arguments.length){e=""+e;const t=this._nodes.get(e);if(!t)throw new f(`Graph.${o}: could not find the "${e}" node in the graph.`);return function(e,t,i){let n=h();return"undirected"!==e&&("out"!==t&&void 0!==i.in&&(n=u(n,x(i.in))),"in"!==t&&void 0!==i.out&&(n=u(n,x(i.out,t?void 0:i.key)))),"directed"!==e&&void 0!==i.undirected&&(n=u(n,x(i.undirected))),n}(n,r,t)}if(2===arguments.length){e=""+e,t=""+t;const i=this._nodes.get(e);if(!i)throw new f(`Graph.${o}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new f(`Graph.${o}:  could not find the "${t}" target node in the graph.`);return function(e,t,i,n){let r=h();return"undirected"!==e&&(void 0!==i.in&&"out"!==t&&n in i.in&&(r=u(r,S(i.in,n))),void 0!==i.out&&"in"!==t&&n in i.out&&(t||i.key!==n)&&(r=u(r,S(i.out,n)))),"directed"!==e&&void 0!==i.undirected&&n in i.undirected&&(r=u(r,S(i.undirected,n))),r}(n,r,i,t)}throw new p(`Graph.${o}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}(e,t)}))}(Y),function(e){O.forEach((t=>{(function(e,t){const{name:i,type:n,direction:r}=t;e.prototype[i]=function(e){if("mixed"!==n&&"mixed"!==this.type&&n!==this.type)return[];e=""+e;const t=this._nodes.get(e);if(void 0===t)throw new f(`Graph.${i}: could not find the "${e}" node in the graph.`);return function(e,t,i){if("mixed"!==e){if("undirected"===e)return Object.keys(i.undirected);if("string"==typeof t)return Object.keys(i[t])}const n=[];return U(!1,e,t,i,(function(e){n.push(e)})),n}("mixed"===n?this.type:n,r,t)}})(e,t),function(e,t){const{name:i,type:n,direction:r}=t,o="forEach"+i[0].toUpperCase()+i.slice(1,-1);e.prototype[o]=function(e,t){if("mixed"!==n&&"mixed"!==this.type&&n!==this.type)return;e=""+e;const i=this._nodes.get(e);if(void 0===i)throw new f(`Graph.${o}: could not find the "${e}" node in the graph.`);U(!1,"mixed"===n?this.type:n,r,i,t)};const s="map"+i[0].toUpperCase()+i.slice(1);e.prototype[s]=function(e,t){const i=[];return this[o](e,((e,n)=>{i.push(t(e,n))})),i};const a="filter"+i[0].toUpperCase()+i.slice(1);e.prototype[a]=function(e,t){const i=[];return this[o](e,((e,n)=>{t(e,n)&&i.push(e)})),i};const d="reduce"+i[0].toUpperCase()+i.slice(1);e.prototype[d]=function(e,t,i){if(arguments.length<3)throw new p(`Graph.${d}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let n=i;return this[o](e,((e,i)=>{n=t(n,e,i)})),n}}(e,t),function(e,t){const{name:i,type:n,direction:r}=t,o=i[0].toUpperCase()+i.slice(1,-1),s="find"+o;e.prototype[s]=function(e,t){if("mixed"!==n&&"mixed"!==this.type&&n!==this.type)return;e=""+e;const i=this._nodes.get(e);if(void 0===i)throw new f(`Graph.${s}: could not find the "${e}" node in the graph.`);return U(!0,"mixed"===n?this.type:n,r,i,t)};const a="some"+o;e.prototype[a]=function(e,t){return!!this[s](e,t)};const d="every"+o;e.prototype[d]=function(e,t){return!this[s](e,((e,i)=>!t(e,i)))}}(e,t),function(e,t){const{name:i,type:n,direction:r}=t,o=i.slice(0,-1)+"Entries";e.prototype[o]=function(e){if("mixed"!==n&&"mixed"!==this.type&&n!==this.type)return h();e=""+e;const t=this._nodes.get(e);if(void 0===t)throw new f(`Graph.${o}: could not find the "${e}" node in the graph.`);return function(e,t,i){if("mixed"!==e){if("undirected"===e)return N(null,i,i.undirected);if("string"==typeof t)return N(null,i,i[t])}let n=h();const r=new M;return"undirected"!==e&&("out"!==t&&(n=u(n,N(r,i,i.in))),"in"!==t&&(n=u(n,N(r,i,i.out)))),"directed"!==e&&(n=u(n,N(r,i,i.undirected))),n}("mixed"===n?this.type:n,r,t)}}(e,t)}))}(Y);class Q extends Y{constructor(e){const i=t({type:"directed"},e);if("multi"in i&&!1!==i.multi)throw new p("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("directed"!==i.type)throw new p('DirectedGraph.from: inconsistent "'+i.type+'" type in given options!');super(i)}}class J extends Y{constructor(e){const i=t({type:"undirected"},e);if("multi"in i&&!1!==i.multi)throw new p("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("undirected"!==i.type)throw new p('UndirectedGraph.from: inconsistent "'+i.type+'" type in given options!');super(i)}}class Z extends Y{constructor(e){const i=t({multi:!0},e);if("multi"in i&&!0!==i.multi)throw new p("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");super(i)}}class V extends Y{constructor(e){const i=t({type:"directed",multi:!0},e);if("multi"in i&&!0!==i.multi)throw new p("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("directed"!==i.type)throw new p('MultiDirectedGraph.from: inconsistent "'+i.type+'" type in given options!');super(i)}}class X extends Y{constructor(e){const i=t({type:"undirected",multi:!0},e);if("multi"in i&&!0!==i.multi)throw new p("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("undirected"!==i.type)throw new p('MultiUndirectedGraph.from: inconsistent "'+i.type+'" type in given options!');super(i)}}function ee(e){e.from=function(i,n){const r=t({},i.options,n),o=new e(r);return o.import(i),o}}ee(Y),ee(Q),ee(J),ee(Z),ee(V),ee(X),Y.Graph=Y,Y.DirectedGraph=Q,Y.UndirectedGraph=J,Y.MultiGraph=Z,Y.MultiDirectedGraph=V,Y.MultiUndirectedGraph=X,Y.InvalidArgumentsGraphError=p,Y.NotFoundGraphError=f,Y.UsageGraphError=l,i(809),i(903),new Y})()})();
//# sourceMappingURL=home.js.map